[{"id":1,"time":1619798400000,"title":"new文章标题new文章标题","intro":"new简介new简介new简介new简介","content":"new文章内容new文章内容new文章内容new文章内容new文章内容"},{"id":2,"time":1619798400000,"title":"string 2","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":3,"time":1619798400000,"title":"string 3","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":4,"time":1622476800000,"title":"string 4","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":5,"time":1622476800000,"title":"string 5","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":6,"time":1622476800000,"title":"string 6","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":7,"time":1622476800000,"title":"stringfdasdf 7","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":8,"time":1625068800000,"title":"stringsdfafsdf 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":9,"time":1627747200000,"title":"stringfadfas 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":10,"time":1627747200000,"title":"stringewrewrwe 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":11,"time":1627747200000,"title":"striewerwerng 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":12,"time":1627747200000,"title":"strinadfadfg 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":13,"time":1627747200000,"title":"stridfdfng 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":14,"time":1627747200000,"title":"stringdfgg 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":15,"time":1630425600000,"title":"st2414ring 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":16,"time":1630425600000,"title":"str244ing 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":17,"time":1633046400000,"title":"str4444ing 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":18,"time":1633046400000,"title":"stri4444ng 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":19,"time":1635724800000,"title":"string444 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":20,"time":1635724800000,"title":"string232313 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":21,"time":1638316800000,"title":"string 8213231321","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":22,"time":1638316800000,"title":"string 82321321","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":23,"time":1638316800000,"title":"string 8ttttt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":24,"time":1638316800000,"title":"string 8ttttt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":25,"time":1638316800000,"title":"sttttttring 8","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":26,"time":1638316800000,"title":"tsttritg tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":27,"time":1638316800000,"title":"string ttttttttt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":28,"time":1638316800000,"title":"string111111111 tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":29,"time":1640966400000,"title":"strin333333333g tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":30,"time":1640966400000,"title":"strin3333g tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":31,"time":1640966400000,"title":"strin2323g tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":32,"time":1640966400000,"title":"string 132tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":33,"time":1640966400000,"title":"string222 tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":34,"time":1640966400000,"title":"strin222g tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":35,"time":1640966400000,"title":"stringstring tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":36,"time":1644281641713,"title":"string tstringt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":37,"time":1644281642200,"title":"stringstringstring tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":38,"time":1644281642670,"title":"12332string tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":39,"time":1644281643157,"title":"string 21321tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":40,"time":1644281643628,"title":"string t33t","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":41,"time":1644281644120,"title":"string11 tt","intro":"嘟嘟读11","content":"文章内容文章内容文章内容文章内容"},{"id":42,"time":1644281644607,"title":"string213 tt","intro":"嘟嘟读11","content":"#我是标题\r\n文章内容文章内容文章内容文章内容"},{"id":43,"time":1651785344227,"title":"移动端适配方案(rem+js)","intro":"移动端适配方案(rem+js)移动端适配方案(rem+js)移动端适配方案(rem+js)","content":"```\r\n\r\n## 2.rem的基准值\r\n\r\n**下面以750px设计稿为例**\r\n\r\n首先设置meta viewport标签\r\n\r\n```html\r\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"&gt;\r\n```\r\n\r\n```js\r\n// 参数：设计图的宽\r\n// 使用：假如量取设计图元素宽10像素，css设置为0.1rem(除以100)即可\r\n!(function(designWidth) {\r\n    // 视口的CSS像素宽\r\n    var viewportWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth\r\n    var htmlFontSize\r\n    if(viewportWidth &gt;= 560) {\r\n        // 手机页面在PC预览会过大，这里进行单独处理\r\n        htmlFontSize = 54\r\n    } else {\r\n        /*\r\n        为了按比例还原设计稿：\r\n        \t1px / 设计图宽 = 1rem / 页面宽\r\n        \t1rem = (1 / 设计图宽) * 页面宽\r\n        \tfont-size不能太小，所以放大100倍\r\n        \t那么↓↓↓\r\n        */\r\n        htmlFontSize = (1 / designWidth) * viewportWidth * 100\r\n    }\r\n    document.documentElement.style.fontSize = htmlFontSize + 'px'\r\n})(750);\r\n```\r\n"},{"id":44,"time":1651785585116,"title":"移动端适配方案(rem+js)2","intro":"移动端适配方案(rem+js)移动端适配方案(rem+js)移动端适配方案(rem+js)","content":"# 移动端适配方案(rem+js)\r\n\r\n#计算机/web/css/移动端 \r\n\r\n## 1.什么是rem\r\n\r\nrem就是是相对于html的font-size属性的值\r\n\r\n```css\r\nhtml {\r\n    font-size: 100px;\r\n}\r\n.con {\r\n    font-size: .16rem; /*这里就代表 100*0.16 = 16px*/\r\n}\r\n```\r\n\r\n## 2.rem的基准值\r\n\r\n**==下面以750px设计稿为例==**\r\n\r\n首先设置meta viewport标签\r\n\r\n```html\r\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"&gt;\r\n```\r\n\r\n```js\r\n// 参数：设计图的宽\r\n// 使用：假如量取设计图元素宽10像素，css设置为0.1rem(除以100)即可\r\n!(function(designWidth) {\r\n    // 视口的CSS像素宽\r\n    var viewportWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth\r\n    var htmlFontSize\r\n    if(viewportWidth &gt;= 560) {\r\n        // 手机页面在PC预览会过大，这里进行单独处理\r\n        htmlFontSize = 54\r\n    } else {\r\n        /*\r\n        为了按比例还原设计稿：\r\n        \t1px / 设计图宽 = 1rem / 页面宽\r\n        \t1rem = (1 / 设计图宽) * 页面宽\r\n        \tfont-size不能太小，所以放大100倍\r\n        \t那么↓↓↓\r\n        */\r\n        htmlFontSize = (1 / designWidth) * viewportWidth * 100\r\n    }\r\n    document.documentElement.style.fontSize = htmlFontSize + 'px'\r\n})(750);\r\n```\r\n\r\n"},{"id":45,"time":1651785704816,"title":"JS - 布尔运算符","intro":"介绍ES5布尔运算符","content":"# 布尔运算符\r\n\r\n#计算机/web/js/es5 \r\n\r\n## 概述\r\n\r\n布尔运算符用于将表达式转为布尔值，一共包含四个运算符。\r\n\r\n- 取反运算符：`!`\r\n- 且运算符：`&&`\r\n- 或运算符：`||`\r\n- 三元运算符：`?:`\r\n\r\n## 取反运算符（!）\r\n\r\n用于将布尔值变为相反值，即`true`变成`false`，`false`变成`true`。\r\n\r\n```js\r\n!true // false\r\n!false // true\r\n```\r\n\r\n对于非布尔值，会先转换为布尔值，再取反\r\n\r\n```js\r\n!undefined // true\r\n!null // true\r\n!0 // true\r\n!NaN // true\r\n!\"\" // true\r\n\r\n!54 // false\r\n!'hello' // false\r\n![] // false\r\n!{} // false\r\n```\r\n\r\n如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与`Boolean`函数的作用相同。这是一种常用的类型转换的写法。\r\n\r\n```js\r\n!!x\r\n// 等同于\r\nBoolean(x)\r\n```\r\n\r\n## 且运算符（&&）\r\n\r\n且运算符（`&&`）往往用于多个表达式的求值。\r\n\r\n它的运算规则是：**如果第一个运算子的布尔值为`true`，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为`false`，则直接返回第一个运算子的值，且不再对第二个运算子求值。**\r\n\r\n```js\r\n't' && '' // \"\"\r\n't' && 'f' // \"f\"\r\n't' && (1 + 2) // 3\r\n'' && 'f' // \"\"\r\n'' && '' // \"\"\r\n\r\nvar x = 1;\r\n(1 - 1) && ( x += 1) // 0\r\nx // 1\r\n```\r\n\r\n上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为`false`，则直接返回它的值`0`，而不再对第二个运算子求值，所以变量`x`的值没变。\r\n\r\n\r\n\r\n**这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代`if`结构，比如下面是一段`if`结构的代码，就可以用且运算符改写。**\r\n\r\n```js\r\nif (i) {\r\n  doSomething();\r\n}\r\n\r\n// 等价于\r\n\r\ni && doSomething();\r\n```\r\n\r\n上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用。\r\n\r\n\r\n\r\n且运算符可以多个连用，这时返回第一个布尔值为`false`的表达式的值。如果所有表达式的布尔值都为`true`，则返回最后一个表达式的值。\r\n\r\n```js\r\ntrue && 'foo' && '' && 4 && 'foo' && true\r\n// ''\r\n\r\n1 && 2 && 3\r\n// 3\r\n```\r\n\r\n上面代码中，例一里面，第一个布尔值为`false`的表达式为第三个表达式，所以得到一个空字符串。例二里面，所有表达式的布尔值都是`true`，所有返回最后一个表达式的值`3`。\r\n\r\n## 或运算符（||）\r\n\r\n或运算符（`||`）也用于多个表达式的求值。**它的运算规则是：如果第一个运算子的布尔值为`true`，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为`false`，则返回第二个运算子的值。**\r\n\r\n```js\r\n't' || '' // \"t\"\r\n't' || 'f' // \"t\"\r\n'' || 'f' // \"f\"\r\n'' || '' // \"\"\r\n```\r\n\r\n短路规则对这个运算符也适用。\r\n\r\n```js\r\nvar x = 1;\r\ntrue || (x = 2) // true\r\nx // 1\r\n```\r\n\r\n上面代码中，或运算符的第一个运算子为`true`，所以直接返回`true`，不再运行第二个运算子。所以，`x`的值没有改变。这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为“短路”（short-cut）。\r\n\r\n或运算符可以多个连用，这时返回第一个布尔值为`true`的表达式的值。如果所有表达式都为`false`，则返回最后一个表达式的值。\r\n\r\n```js\r\nfalse || 0 || '' || 4 || 'foo' || true\r\n// 4\r\n\r\nfalse || 0 || ''\r\n// ''\r\n```\r\n\r\n上面代码中，例一里面，第一个布尔值为`true`的表达式是第四个表达式，所以得到数值4。例二里面，所有表达式的布尔值都为`false`，所以返回最后一个表达式的值。\r\n\r\n**或运算符常用于为一个变量设置默认值。**\r\n\r\n```js\r\nfunction saveText(text) {\r\n  text = text || '';\r\n  // ...\r\n}\r\n\r\n// 或者写成\r\nsaveText(this.text || '')\r\n```\r\n\r\n上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。\r\n\r\n## 三元条件运算符（?:）\r\n\r\n三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为`true`，则返回第二个表达式的值，否则返回第三个表达式的值。\r\n\r\n```js\r\n't' ? 'hello' : 'world' // \"hello\"\r\n0 ? 'hello' : 'world' // \"world\"\r\n```\r\n\r\n通常来说，三元条件表达式与`if...else`语句具有同样表达效果，前者可以表达的，后者也能表达。**但是两者具有一个重大差别，`if...else`是语句，没有返回值；三元条件表达式是表达式，具有返回值。**所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用`if..else`。\r\n\r\n```js\r\nconsole.log(true ? 'T' : 'F');\r\n```\r\n\r\n上面代码中，`console.log`方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用`if...else`语句，就必须改变整个代码写法了。"},{"id":46,"time":1651786569309,"title":"<div style='width: 100px; height: 100px;background: #000;","intro":"React - Hook 简介 <div style='width: 100px; height: 100px;background: #000;","content":"# React - Hook\r\n\r\n[点我](1)\r\n  <div style='width: 100px; height: 100px;background: #000;'></div>\r\n == 高亮 =="},{"id":47,"time":1651880524368,"title":"React - Hook","intro":"介绍官方提供的几个 react hook","content":"# React - Hook\n\n#计算机/web/react \n\n## Hook 简介\n\nHook 是 React 16.8 引入的新特性。\n\n它使我们能够不用编写 Class 组件，采用 **函数式组件 + hook** 的方式完成开发（hook 用于管理 state、模拟生命周期方法…）。\n\n优势：\n\n- 极大地简洁了代码\n\n- 无需使用 `this`（在大型项目中判断 `this` 是谁需要付出额外的心智负担）。\n\n## 使用规则\n\nHook 就是 JavaScript 函数，使用它们需要准守两个规则：\n\n- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。\n- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（[React - 自定义Hook](React%20-%20自定义Hook.md)例外）\n\n## 基本使用\n\n这里用一个计数器案例来演示 “函数式组件 + hook” 的简洁性\n\n```jsx\nimport {React, useState} from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <div>当前技术: { count }</div>\n      &lt;button onClick={e =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;\n      &lt;button onClick={e =&gt; setCount(count - 1)}&gt;-1&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n对比 class 方式它非常的简洁易读！\n\n## useState\n\n基本和 class 组件的 state 相同。\n\n对于 `const [names, setNames] = useState(['小红', '小白'])`：\n\n- names 为该状态的变量名。\n- setNames 用于更新状态。\n- useState 的参数为变量的默认值，可以是有返回值的函数，可为空。\n\n&gt; React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\n\n上面这段话的意思就是：`setState` 不会因为组件重新渲染而重新创建（内存地址不变）。你把`setState` 传给其它组件（memo 包裹），浅层对比一样，不会导致其重新渲染。\n\n### 例1：管理多个状态\n\n可以编写多个 `useState` 管理多个状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function MultiHookState() {\n  const [names, setNames] = useState(['小红', '小白'])\n  const [age, setAge] = useState(18)\n  return (\n    <div>\n      <ul>\n        {age}\n        {\n          names.map((item, index) =&gt; {\n            return <li>{item}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例2：管理复杂状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ComplexHookState() {\n  const [students, setStudents] = useState([\n    { id: 110, name: \"djs\", age: 18 },\n    { id: 111, name: \"kdls\", age: 33 },\n    { id: 112, name: \"ddd\", age: 15 },\n  ])\n\n  const incrementAgeWithIndex = (index) =&gt; {\n    let s = [...students]\n    s[index].age +=1\n    setStudents(s)\n  }\n  return (\n    <div>\n      <ul>\n        {\n          students.map((item, index) =&gt; {\n            return <li>\n              <span>姓名：{item.name}</span>\n              <span>年龄：{item.age}</span>\n              &lt;button onClick={() =&gt; { incrementAgeWithIndex(index) }}&gt;\n                年龄+1\n              &lt;/button&gt;\n            </li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例3：useState 参数可以是函数\n\n需要有返回值，作为其默认值。\n\n```jsx\nconst [todos, setTodos] = useState(() =&gt; {\n  // 读取本地存储\n  return JSON.parse(window.localStorage.getItem('todos'))\n})\n```\n\n### 例4：set 函数的参数可以为函数\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ParameterCanBeAFunction() {\n  const [count, setCount] = useState(10)\n  const handleCount = () =&gt; {\n    // 以下连续操作会被合并，只会加1。类似 setState({})\n    // setcount(count + 1)\n    // setcount(count + 1)\n    // setcount(count + 1)\n\n    // 使用前一个状态进行累加\n    setCount((prevCount) =&gt; (prevCount + 1))\n    setCount((prevCount) =&gt; (prevCount + 1))\n    setCount((prevCount) =&gt; (prevCount + 1))\n  }\n  return (\n    <div>\n      { count }\n      &lt;button onClick={handleCount}&gt;累加的方式 +3&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n## useEffect\n\n用该 hook 来模拟 class 组件的生命周期方法：`componentDidMount`、 `componentDidUpdate`、 `componentWillUnmount`。\n\n&gt; 参考：[React - 组件的生命周期](React%20-%20组件的生命周期.md)。\n\n### 例1：随着状态更新网页 titile\n\n```jsx\nimport React, { useEffect, useState } from 'react'\n\nexport default function TitleWithDataUpdate() {\n  const [count, setCount] = useState(0)\n  useEffect(() =&gt; {\n    document.title = '当前计数' + count\n  })\n  return (\n    <div>\n      {count}\n      &lt;button onClick={() =&gt; { setCount(count + 1) }}&gt;+1&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n&gt; 相当于使用了 class 组件的 `componentDidMount` （初始更新 title）和 `componentDidUpdate` （状态改变更新 title）\n\n### 例2：模拟订阅与取消订阅\n\n`useEffect` 在不带第二参数的情况下:\n\n- 第一次渲染和之后的每次组件重新渲染，都会重新调用 `useEffect`。这在某些情况下有助于减少BUG（如：数据更新，需要先清理原来事件，再重新订阅）\n\n- 这种情况每次返回的都是一个新的 `useEffect` 函数。\n\n```jsx\nimport React, { useEffect, useState } from 'react'\n\nexport default function EffectHookCancelDemo() {\n  const [count, setCount] = useState(0)\n  useEffect(() =&gt; {\n    console.log('DOM更新后 订阅事件,或其他操作')\n    return () =&gt; {\n      console.log('DOM移除后 取消事件')\n    }\n  })\n}\n```\n\n### 例3：初次渲染订阅事件，组件卸载取消订阅\n\n如果只想在组件创建时订阅事件，组件卸载时取消订阅，可以带第二参数`[]`。\n\n```jsx\nuseEffect(() =&gt; {\n  console.log('DOM更新后 订阅事件')\n  return () =&gt; {\n    console.log('DOM移除后 取消事件')\n  }\n}, [])\n```\n\n&gt; 上面例子类似于 class 组件的： `componentDidMount` 和 `componentWillUnmount` 。\n\n### 例4：性能优化，在依赖状态变化时才重新执行 `useEffect `\n\n下面例子初次渲染会订阅事件，在 userID 变化时才重新执行 `useEffect `（取消事件，重新订阅）。\n\n```jsx\nuseEffect(() =&gt; {\n  console.log('DOM更新后 订阅事件')\n  return () =&gt; {\n    console.log('DOM移除后 取消事件')\n  }\n}, [userID])\n```\n\n### 例5：多个 useEffect 同时使用\n\n```jsx\n// 以下 useEffect 会依次执行,这样做以实现逻辑分离。\nuseEffect(() =&gt; {\n  console.log('网络请求')\n})\n\nuseEffect(() =&gt; {\n  console.log('修改DOM')\n})\n\nuseEffect(() =&gt; {\n  console.log('订阅事件')\n  return () =&gt; {\n    console.log('取消事件')\n  }\n})\n```\n\n## useContext\n\n[Context Consumer](React%20-%20context%20向后代组件共享数据.md#Context%20Consumer)：←该笔记演示了两组 context 消费组件的使用方法，如果是5组 context 呢？那嵌套可就麻烦了。\n\nuseContext 就是为了解决 context 消费组件嵌套地狱的问题。\n\n### 例子\n\n提供组件\n\n```jsx\n// 需要导出 Context\nexport const ThemeContext = React.createContext({ background: \"#ddd\" })\nexport const UserDataContext = React.createContext({ name: '无', age: 0 })\n\nexport default function App() {\n  return (\n    <div>\n      &lt;ThemeContext.Provider value={{ background: \"#eeeeee\" }}&gt;\n        &lt;UserDataContext.Provider value={{ name: \"小明\", age: 18 }}&gt;\n          &lt;UseOfUseContext /&gt;\n        &lt;/UserDataContext.Provider&gt;\n      &lt;/ThemeContext.Provider&gt;\n    </div>\n  )\n}\n```\n\n消费组件\n\n```jsx\nimport React, { useContext } from 'react'\n// 导入 Context\nimport { ThemeContext, UserDataContext } from '../App'\n\nexport default function UseOfUseContext() {\n  // 拿到数据\n  const theme = useContext(ThemeContext)\n  const userData = useContext(UserDataContext)\n  return (\n    <div>\n      用户名：{ userData.name }|\n      年龄：{ userData.age }\n    </div>\n  )\n}\n```\n\n上方代码可见无需嵌套即可拿到数据，简洁很多。\n\n## useReducer\n\n`useReducer` 是 `useState` 的替代品，并不是用来替代 Redux 的。\n\n它不会组件间共享数据，即使引用的是同一个 `reducer`，但用法类似于 [Redux](React%20-%20Redux%201.%E5%88%9D%E6%8E%A2.md) 的 `reducer` 函数。\n\n使用场景：`useState` 逻辑太复杂需要拆分任务时。\n\n### 例子\n\n先编写 reducer.js \n\n```jsx\nexport default (state, action) =&gt; {\n  switch(action.type) {\n    case 'increment':\n      return { ...state, count: state.count + 1 }\n    case 'decrement':\n      return { ...state, count: state.count - 1 }\n    default:\n      return state\n  }\n}\n```\n\n在 home1.js 中使用\n\n```jsx\nimport React, { useReducer } from 'react'\n// 导入\nimport reducer from './reducer'\n\nexport default function Home1() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 })\n  return (\n    <div>\n      home1当前数字：{state.count}\n      &lt;button onClick={() =&gt; { dispatch({ type: 'increment' }) }}&gt;\n        +1\n      &lt;/button&gt;\n    </div>\n  )\n}\n```\n\n为了演示不会共享 reducer ，在 home2.js 中引入同一个 reducer\n\n```jsx\nimport React, { useReducer } from 'react'\n\nimport reducer from './reducer'\n\nexport default function Home2() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 })\n  return (\n    <div>\n      home2当前数字：{state.count}\n      &lt;button onClick={() =&gt; { dispatch({ type: 'increment' }) }}&gt;+1&lt;/button&gt;\n    </div>\n  )\n```\n\n通过演示可以发现，它们的数据是独立存储的。\n\n## useCallback\n\n用于性能优化。\n\n在依赖 state 没变时，返回同一个函数（相同内存地址）。\n\n```jsx\n// count 只要不变，即使当前组件重新渲染也返回同一个函数。\nconst s = useCallback(\n  () =&gt; {\n    setCount(count + 1)\n  },\n  [count]\n)\n```\n\n利用该特性，在传递回调函数给子组件时，可以避免不必要的重新 render（对于函数组件，配合 `memo`）。\n\n- 普通函数即使使用了 `memo` 但是浅层比较时函数已经变了（内存地址不同），会导致重新 render 浪费性能。\n\n- 使用了 useCallback 的组件只要依赖状态不变，就会返回相同的函数，正确跳过不必要的渲染。\n\n### 例子\n\n```jsx\nimport React, { useState, useCallback, memo } from 'react'\n\n// memo 只进行浅层比较（对比函数内存地址），\n// 没有变就不会重新 render。\nconst CounterButton = memo((props) =&gt; {\n  console.log(props.name);\n  return &lt;button onClick={props.increment}&gt;+1&lt;/button&gt;\n})\n\n\nexport default function CorrectUsecallback() {\n  const [count, setCount] = useState(0)\n  const [show, setShow] = useState(true)\n  \n  // 第二参数为空，总是返回同一个函数\n  const increment1 = useCallback(\n    () =&gt; {\n      setCount(count + 1)\n    },\n    []\n  )\n  // 本组件重新 render 时，这里会重新创建函数\n  const increment2 = () =&gt; {\n    setCount(count + 1)\n  }\n  return (\n    <div>\n      {count}\n      &lt;CounterButton increment={increment1} name='性能优化'&gt;&lt;/CounterButton&gt;\n      &lt;CounterButton increment={increment2} name='未性能优化'&gt;&lt;/CounterButton&gt;\n      {/* 切换show会导致本组件重新渲染 */}\n      &lt;button onClick={ () =&gt; { setShow(!show) } }&gt;切换show&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n## useMemo\n\n用于性能优化。\n\n在依赖 state 不变的情况下，返回“记忆值”。\n\n应用场景：\n\n- 对于复杂计算。只要依赖不变，直接返回计算结果，而不必在每次重新 render 时都计算一遍。（有点像 vue 的计算属性。）\n- 对于引用类型，传递给子组件使用。保证即使重新 render 只要依赖不变都返回同一个对象，子组件配合 `memo` 以正确跳过不必要的 render。\n\n### 例1：复杂计算缓存结果\n\n```jsx\nimport React, { useState, useMemo } from 'react'\n// 计算阶乘的函数\nconst factorial = (n) =&gt; {\n  if(n &lt;= 1) return 1\n  return n * factorial(n - 1)\n}\n\nexport default function UseMemoDemo1() {\n  const [count, setCount] = useState(15)\n  const [show, setShow] = useState(true)\n  // 在count没有发生改变时，直接返回缓存的结果，以节约性能\n  const result = useMemo(() =&gt; {\n    console.log('计算阶乘结果中');\n    return factorial(count)\n  }, [count])\n\n  return (\n    <div>\n      {count}的阶乘：{result}\n      &lt;button onClick={() =&gt; { setCount(count + 1) }}&gt;+1&lt;/button&gt;\n      {/* 切换show会导致本组件重新渲染，已验证是否重新计算 */}\n      &lt;button onClick={() =&gt; { setShow(!show) }}&gt;切换show&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n### 例2：向子组件传入引用类型\n\n```jsx\nimport React, { useState, useMemo, memo } from 'react'\n\nconst MyInfo = memo((props) =&gt; {\n  console.log(`${props.info.name}render`);\n  return (\n    <div>\n      {props.info.name}\n      {props.info.age}\n    </div>\n  )\n})\n\nexport default function UseMemoDemo1() {\n  const [show, setShow] = useState(true)\n\n  const info1 = useMemo(() =&gt; {\n    return { name: '小明', age: 18 }\n  }, [])\n\n  const info2 = { name: '小红', age: 18 }\n  \n  return (\n    <div>\n      {/* 切换show会导致本组件重新渲染 */}\n      &lt;button onClick={() =&gt; { setShow(!show) }}&gt;切换show&lt;/button&gt;\n\n      {/* 点击上面按钮可以发现，\n          使用了 useMemo 的 小明组件 没有重新 render，\n          这是因为当前组件重新 render 时，\n          info1 返回的是同一个对象内存地址，\n          info2 重新指向了一个新的内存地址，\n          MyInfo 中使用 memo 进行浅层比较，自然不会更新 小明组件。\n      */}\n      &lt;MyInfo info={info1}&gt;&lt;/MyInfo&gt;\n      &lt;MyInfo info={info2}&gt;&lt;/MyInfo&gt;\n    </div>\n  )\n}\n```\n\n## useRef\n\n返回一个 ref 对象，返回的对象在组件的整个生命周期保持不变。\n\n### 例1：引入DOM/class组件实例\n\n```jsx\nimport React, { useRef } from 'react'\n\nclass T1 extends React.PureComponent {\n  render() {\n    return <h2>T1</h2>\n  }\n}\n\nexport default function UseRefDemo1() {\n  const inputRef = useRef()\n  const t1Ref = useRef()\n\n  const changeDOM = () =&gt; {\n    inputRef.current.focus()\n    console.log(t1Ref)\n  }\n\n  return (\n    <div>\n      &lt;input ref={inputRef} type=\"text\"/&gt;\n      &lt;T1 ref={t1Ref}&gt;&lt;/T1&gt;\n      &lt;button onClick={changeDOM}&gt;changeDOM&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n### 例2：保存任何可变值\n\n在组件的整个生命周期保持不变，类似于 class 的实例属性。这意味着可以用于保存之前某一刻的状态值，需要时恢复即可。\n\n```jsx\nimport React, { useRef, useState, useEffect } from 'react'\n\nexport default function UseRefDemo2() {\n  const [count, setCount] = useState(100)\n  const numRef = useRef(count)\n\n  // 在组件挂载时，保存初始 count 状态\n  useEffect(() =&gt; {\n    numRef.current = count\n  }, [])\n\n  return (\n    <div>\n      初始count：{numRef.current}\n      count本次的值：{count}\n      &lt;button onClick={ () =&gt; { setCount(count + 100) } }&gt;+100&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n## useImperativeHandle\n\n该 hook 用于控制子组件要将哪些东西暴露给向父组件。没有暴露的东西，父组件无权拿到、使用，达到权限控制的目的。\n\n一般建议使用，使程序更可控。\n\n参数：\n-   接收一个`ref`\n-   接收一个函数，**这个函数返回的对象即是要暴露出的`ref`**\n-   类似`useEffect`，接收一个依赖数组\n\n&gt; ref转发见：[React - Refs转发](React%20-%20Refs转发.md)\n\n### 例子\n\n```jsx\nimport React, { forwardRef, useRef, useImperativeHandle } from 'react'\n\nconst Input = forwardRef((props, ref) =&gt; {\n  const inputRef1 = useRef()\n  const inputRef2 = useRef()\n\n  useImperativeHandle(\n    ref,\n    () =&gt; ({\n      f: () =&gt; {\n        inputRef1.current.focus()\n      },\n      /* 更多 */\n    }),\n    [inputRef1],\n  )\n  return (\n    <div>\n      &lt;input ref={inputRef1} type=\"text\" /&gt;\n      <br />\n      &lt;input ref={inputRef2} type=\"text\" /&gt;\n    <div />\n  )\n})\n\nexport default function UseImperativeHandleDemo() {\n  const inputRef = useRef()\n  return (\n    <div>\n      &lt;Input ref={inputRef}&gt;&lt;/Input&gt;\n      &lt;button onClick={() =&gt; { inputRef.current.f() }}&gt;聚焦&lt;/button&gt;\n      {/* 这里只拿得到 useImperativeHandle 暴露的对象，\n      而不是 input1 元素，防止父组件随意的操作 DOM */}\n      &lt;button onClick={() =&gt; { console.log(inputRef.current); }}&gt;打印&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n上面例子仅暴露了 `useImperativeHandle` 第二个参数（函数）返会的对象，`input1` 元素本身并未暴露，`inputRef2` 也为暴露，达到权限控住目的。第三个参数意思是：`inputRef1` 变化时更新这个挂载。\n\n点击\"聚焦\" button 成功聚焦 `input1` ，点击“打印” button 会打印：\n\n```js\n{\n  f: () =&gt; {\n    inputRef1.current.focus()\n  }\n}\n```\n\n## useLayoutEffect\n\n`useLayoutEffect` 和 `useEffet` 的唯一区别就是：\n\n- `useLayoutEffect` 在更新真实 DOM 前操作，会阻塞页面渲染。\n- `useEffect` 在真实 DOM 更新之后才操作，不会阻塞页面渲染。\n\n一般情况下都使用 `useEffect`，只有特殊情况才使用 `useLayoutEffect`。\n\n### 例子：防止页面闪烁\n\n计数器案例：点击 改变 count 后，又通过不同方式再改变 count。\n\n`useEffect` 方式：页面二次渲染。\n\n```jsx\nimport React, { useState, useEffect } from 'react'\n\nexport default function EffectCounterDemo() {\n  const [count, setCount] = useState(10)\n\n  useEffect(() =&gt; {\n    if(count === 0) {\n      setCount(Math.random() + 200)\n    }\n  }, [count])\n\n  return (\n    <div>\n      {count}\n      {/* \n        点击可以发现有个明显的闪烁。\n        这是因为 useEffect 是在 DOM 更新完毕后才执行，\n        count 又被更新，页面二次渲染导致。\n       */}\n      &lt;button onClick={() =&gt; { setCount(0) }}&gt;改变count&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n`useLayoutEffect` 方式，合并 count 为最新值不会二次渲染。\n\n```jsx\nimport React, { useState, useLayoutEffect } from 'react'\n\nexport default function LayoutEffectCounterDemo() {\n  const [count, setCount] = useState(10)\n\t\n  // 在真实 DOM 更新前执行，使得 count 已经覆盖为最新的值了，\n  // 不会导致页面二次渲染\n  useLayoutEffect(() =&gt; {\n    if(count === 0) {\n      setCount(Math.random() + 200)\n    }\n  }, [count])\n\n  return (\n    <div>\n      {count}\n      &lt;button onClick={() =&gt; { setCount(0) }}&gt;改变count&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n"},{"id":48,"time":1651881412255,"title":"React - Hook","intro":"介绍官方提供的几个 react hook","content":"# React - Hook\n\n#计算机/web/react \n\n## Hook 简介\n\nHook 是 React 16.8 引入的新特性。\n\n它使我们能够不用编写 Class 组件，采用 **函数式组件 + hook** 的方式完成开发（hook 用于管理 state、模拟生命周期方法…）。\n\n优势：\n\n- 极大地简洁了代码\n\n- 无需使用 `this`（在大型项目中判断 `this` 是谁需要付出额外的心智负担）。\n\n## 使用规则\n\nHook 就是 JavaScript 函数，使用它们需要准守两个规则：\n\n- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。\n- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（[React - 自定义Hook](React%20-%20自定义Hook.md)例外）\n\n## 基本使用\n\n这里用一个计数器案例来演示 “函数式组件 + hook” 的简洁性\n\n```jsx\nimport {React, useState} from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <div>当前技术: { count }</div>\n      &lt;button onClick={e =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;\n      &lt;button onClick={e =&gt; setCount(count - 1)}&gt;-1&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n对比 class 方式它非常的简洁易读！\n\n## useState\n\n基本和 class 组件的 state 相同。\n\n对于 `const [names, setNames] = useState(['小红', '小白'])`：\n\n- names 为该状态的变量名。\n- setNames 用于更新状态。\n- useState 的参数为变量的默认值，可以是有返回值的函数，可为空。\n\n&gt; React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\n\n上面这段话的意思就是：`setState` 不会因为组件重新渲染而重新创建（内存地址不变）。你把`setState` 传给其它组件（memo 包裹），浅层对比一样，不会导致其重新渲染。\n\n### 例1：管理多个状态\n\n可以编写多个 `useState` 管理多个状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function MultiHookState() {\n  const [names, setNames] = useState(['小红', '小白'])\n  const [age, setAge] = useState(18)\n  return (\n    <div>\n      <ul>\n        {age}\n        {\n          names.map((item, index) =&gt; {\n            return <li>{item}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例2：管理复杂状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ComplexHookState() {\n  const [students, setStudents] = useState([\n    { id: 110, name: \"djs\", age: 18 },\n    { id: 111, name: \"kdls\", age: 33 },\n    { id: 112, name: \"ddd\", age: 15 },\n  ])\n\n  const incrementAgeWithIndex = (index) =&gt; {\n    let s = [...students]\n    s[index].age +=1\n    setStudents(s)\n  }\n  return (\n    <div>\n      <ul>\n        {\n          students.map((item, index) =&gt; {\n            return <li>\n              <span>姓名：{item.name}</span>\n              <span>年龄：{item.age}</span>\n              &lt;button onClick={() =&gt; { incrementAgeWithIndex(index) }}&gt;\n                年龄+1\n              &lt;/button&gt;\n            </li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例3：useState 参数可以是函数\n\n需要有返回值，作为其默认值。\n\n```jsx\nconst [todos, setTodos] = useState(() =&gt; {\n  // 读取本地存储\n  return JSON.parse(window.localStorage.getItem('todos'))\n})\n```\n\n### 例4：set 函数的参数可以为函数\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ParameterCanBeAFunction() {\n  const [count, setCount] = useState(10)\n  const handleCount = () =&gt; {\n    // 以下连续操作会被合并，只会加1。类似 setState({})\n    // setcount(count + 1)\n    // setcount(count + 1)\n    // setcount(count + 1)\n\n    // 使用前一个状态进行累加\n    setCount((prevCount) =&gt; (prevCount + 1))\n    setCount((prevCount) =&gt; (prevCount + 1))\n    setCount((prevCount) =&gt; (prevCount + 1))\n  }\n  return (\n    <div>\n      { count }\n      &lt;button onClick={handleCount}&gt;累加的方式 +3&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n## useEffect\n\n用该 hook 来模拟 class 组件的生命周期方法：`componentDidMount`、 `componentDidUpdate`、 `componentWillUnmount`。\n\n&gt; 参考：[React - 组件的生命周期](React%20-%20组件的生命周期.md)。\n\n### 例1：随着状态更新网页 titile\n\n```jsx\nimport React, { useEffect, useState } from 'react'\n\nexport default function TitleWithDataUpdate() {\n  const [count, setCount] = useState(0)\n  useEffect(() =&gt; {\n    document.title = '当前计数' + count\n  })\n  return (\n    <div>\n      {count}\n      &lt;button onClick={() =&gt; { setCount(count + 1) }}&gt;+1&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n&gt; 相当于使用了 class 组件的 `componentDidMount` （初始更新 title）和 `componentDidUpdate` （状态改变更新 title）\n\n### 例2：模拟订阅与取消订阅\n\n`useEffect` 在不带第二参数的情况下:\n\n- 第一次渲染和之后的每次组件重新渲染，都会重新调用 `useEffect`。这在某些情况下有助于减少BUG（如：数据更新，需要先清理原来事件，再重新订阅）\n\n- 这种情况每次返回的都是一个新的 `useEffect` 函数。\n\n```jsx\nimport React, { useEffect, useState } from 'react'\n\nexport default function EffectHookCancelDemo() {\n  const [count, setCount] = useState(0)\n  useEffect(() =&gt; {\n    console.log('DOM更新后 订阅事件,或其他操作')\n    return () =&gt; {\n      console.log('DOM移除后 取消事件')\n    }\n  })\n}\n```\n\n### 例3：初次渲染订阅事件，组件卸载取消订阅\n\n如果只想在组件创建时订阅事件，组件卸载时取消订阅，可以带第二参数`[]`。\n\n```jsx\nuseEffect(() =&gt; {\n  console.log('DOM更新后 订阅事件')\n  return () =&gt; {\n    console.log('DOM移除后 取消事件')\n  }\n}, [])\n```\n\n&gt; 上面例子类似于 class 组件的： `componentDidMount` 和 `componentWillUnmount` 。\n\n### 例4：性能优化，在依赖状态变化时才重新执行 `useEffect `\n\n下面例子初次渲染会订阅事件，在 userID 变化时才重新执行 `useEffect `（取消事件，重新订阅）。\n\n```jsx\nuseEffect(() =&gt; {\n  console.log('DOM更新后 订阅事件')\n  return () =&gt; {\n    console.log('DOM移除后 取消事件')\n  }\n}, [userID])\n```\n\n### 例5：多个 useEffect 同时使用\n\n```jsx\n// 以下 useEffect 会依次执行,这样做以实现逻辑分离。\nuseEffect(() =&gt; {\n  console.log('网络请求')\n})\n\nuseEffect(() =&gt; {\n  console.log('修改DOM')\n})\n\nuseEffect(() =&gt; {\n  console.log('订阅事件')\n  return () =&gt; {\n    console.log('取消事件')\n  }\n})\n```\n\n## useContext\n\n[Context Consumer](React%20-%20context%20向后代组件共享数据.md#Context%20Consumer)：←该笔记演示了两组 context 消费组件的使用方法，如果是5组 context 呢？那嵌套可就麻烦了。\n\nuseContext 就是为了解决 context 消费组件嵌套地狱的问题。\n\n### 例子\n\n提供组件\n\n```jsx\n// 需要导出 Context\nexport const ThemeContext = React.createContext({ background: \"#ddd\" })\nexport const UserDataContext = React.createContext({ name: '无', age: 0 })\n\nexport default function App() {\n  return (\n    <div>\n      &lt;ThemeContext.Provider value={{ background: \"#eeeeee\" }}&gt;\n        &lt;UserDataContext.Provider value={{ name: \"小明\", age: 18 }}&gt;\n          &lt;UseOfUseContext /&gt;\n        &lt;/UserDataContext.Provider&gt;\n      &lt;/ThemeContext.Provider&gt;\n    </div>\n  )\n}\n```\n\n消费组件\n\n```jsx\nimport React, { useContext } from 'react'\n// 导入 Context\nimport { ThemeContext, UserDataContext } from '../App'\n\nexport default function UseOfUseContext() {\n  // 拿到数据\n  const theme = useContext(ThemeContext)\n  const userData = useContext(UserDataContext)\n  return (\n    <div>\n      用户名：{ userData.name }|\n      年龄：{ userData.age }\n    </div>\n  )\n}\n```\n\n上方代码可见无需嵌套即可拿到数据，简洁很多。\n\n## useReducer\n\n`useReducer` 是 `useState` 的替代品，并不是用来替代 Redux 的。\n\n它不会组件间共享数据，即使引用的是同一个 `reducer`，但用法类似于 [Redux](React%20-%20Redux%201.%E5%88%9D%E6%8E%A2.md) 的 `reducer` 函数。\n\n使用场景：`useState` 逻辑太复杂需要拆分任务时。\n\n### 例子\n\n先编写 reducer.js \n\n```jsx\nexport default (state, action) =&gt; {\n  switch(action.type) {\n    case 'increment':\n      return { ...state, count: state.count + 1 }\n    case 'decrement':\n      return { ...state, count: state.count - 1 }\n    default:\n      return state\n  }\n}\n```\n\n在 home1.js 中使用\n\n```jsx\nimport React, { useReducer } from 'react'\n// 导入\nimport reducer from './reducer'\n\nexport default function Home1() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 })\n  return (\n    <div>\n      home1当前数字：{state.count}\n      &lt;button onClick={() =&gt; { dispatch({ type: 'increment' }) }}&gt;\n        +1\n      &lt;/button&gt;\n    </div>\n  )\n}\n```\n\n为了演示不会共享 reducer ，在 home2.js 中引入同一个 reducer\n\n```jsx\nimport React, { useReducer } from 'react'\n\nimport reducer from './reducer'\n\nexport default function Home2() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 })\n  return (\n    <div>\n      home2当前数字：{state.count}\n      &lt;button onClick={() =&gt; { dispatch({ type: 'increment' }) }}&gt;+1&lt;/button&gt;\n    </div>\n  )\n```\n\n通过演示可以发现，它们的数据是独立存储的。\n\n## useCallback\n\n用于性能优化。\n\n在依赖 state 没变时，返回同一个函数（相同内存地址）。\n\n```jsx\n// count 只要不变，即使当前组件重新渲染也返回同一个函数。\nconst s = useCallback(\n  () =&gt; {\n    setCount(count + 1)\n  },\n  [count]\n)\n```\n\n利用该特性，在传递回调函数给子组件时，可以避免不必要的重新 render（对于函数组件，配合 `memo`）。\n\n- 普通函数即使使用了 `memo` 但是浅层比较时函数已经变了（内存地址不同），会导致重新 render 浪费性能。\n\n- 使用了 useCallback 的组件只要依赖状态不变，就会返回相同的函数，正确跳过不必要的渲染。\n\n### 例子\n\n```jsx\nimport React, { useState, useCallback, memo } from 'react'\n\n// memo 只进行浅层比较（对比函数内存地址），\n// 没有变就不会重新 render。\nconst CounterButton = memo((props) =&gt; {\n  console.log(props.name);\n  return &lt;button onClick={props.increment}&gt;+1&lt;/button&gt;\n})\n\n\nexport default function CorrectUsecallback() {\n  const [count, setCount] = useState(0)\n  const [show, setShow] = useState(true)\n  \n  // 第二参数为空，总是返回同一个函数\n  const increment1 = useCallback(\n    () =&gt; {\n      setCount(count + 1)\n    },\n    []\n  )\n  // 本组件重新 render 时，这里会重新创建函数\n  const increment2 = () =&gt; {\n    setCount(count + 1)\n  }\n  return (\n    <div>\n      {count}\n      &lt;CounterButton increment={increment1} name='性能优化'&gt;&lt;/CounterButton&gt;\n      &lt;CounterButton increment={increment2} name='未性能优化'&gt;&lt;/CounterButton&gt;\n      {/* 切换show会导致本组件重新渲染 */}\n      &lt;button onClick={ () =&gt; { setShow(!show) } }&gt;切换show&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n## useMemo\n\n用于性能优化。\n\n在依赖 state 不变的情况下，返回“记忆值”。\n\n应用场景：\n\n- 对于复杂计算。只要依赖不变，直接返回计算结果，而不必在每次重新 render 时都计算一遍。（有点像 vue 的计算属性。）\n- 对于引用类型，传递给子组件使用。保证即使重新 render 只要依赖不变都返回同一个对象，子组件配合 `memo` 以正确跳过不必要的 render。\n\n### 例1：复杂计算缓存结果\n\n```jsx\nimport React, { useState, useMemo } from 'react'\n// 计算阶乘的函数\nconst factorial = (n) =&gt; {\n  if(n &lt;= 1) return 1\n  return n * factorial(n - 1)\n}\n\nexport default function UseMemoDemo1() {\n  const [count, setCount] = useState(15)\n  const [show, setShow] = useState(true)\n  // 在count没有发生改变时，直接返回缓存的结果，以节约性能\n  const result = useMemo(() =&gt; {\n    console.log('计算阶乘结果中');\n    return factorial(count)\n  }, [count])\n\n  return (\n    <div>\n      {count}的阶乘：{result}\n      &lt;button onClick={() =&gt; { setCount(count + 1) }}&gt;+1&lt;/button&gt;\n      {/* 切换show会导致本组件重新渲染，已验证是否重新计算 */}\n      &lt;button onClick={() =&gt; { setShow(!show) }}&gt;切换show&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n### 例2：向子组件传入引用类型\n\n```jsx\nimport React, { useState, useMemo, memo } from 'react'\n\nconst MyInfo = memo((props) =&gt; {\n  console.log(`${props.info.name}render`);\n  return (\n    <div>\n      {props.info.name}\n      {props.info.age}\n    </div>\n  )\n})\n\nexport default function UseMemoDemo1() {\n  const [show, setShow] = useState(true)\n\n  const info1 = useMemo(() =&gt; {\n    return { name: '小明', age: 18 }\n  }, [])\n\n  const info2 = { name: '小红', age: 18 }\n  \n  return (\n    <div>\n      {/* 切换show会导致本组件重新渲染 */}\n      &lt;button onClick={() =&gt; { setShow(!show) }}&gt;切换show&lt;/button&gt;\n\n      {/* 点击上面按钮可以发现，\n          使用了 useMemo 的 小明组件 没有重新 render，\n          这是因为当前组件重新 render 时，\n          info1 返回的是同一个对象内存地址，\n          info2 重新指向了一个新的内存地址，\n          MyInfo 中使用 memo 进行浅层比较，自然不会更新 小明组件。\n      */}\n      &lt;MyInfo info={info1}&gt;&lt;/MyInfo&gt;\n      &lt;MyInfo info={info2}&gt;&lt;/MyInfo&gt;\n    </div>\n  )\n}\n```\n\n## useRef\n\n返回一个 ref 对象，返回的对象在组件的整个生命周期保持不变。\n\n### 例1：引入DOM/class组件实例\n\n```jsx\nimport React, { useRef } from 'react'\n\nclass T1 extends React.PureComponent {\n  render() {\n    return <h2>T1</h2>\n  }\n}\n\nexport default function UseRefDemo1() {\n  const inputRef = useRef()\n  const t1Ref = useRef()\n\n  const changeDOM = () =&gt; {\n    inputRef.current.focus()\n    console.log(t1Ref)\n  }\n\n  return (\n    <div>\n      &lt;input ref={inputRef} type=\"text\"/&gt;\n      &lt;T1 ref={t1Ref}&gt;&lt;/T1&gt;\n      &lt;button onClick={changeDOM}&gt;changeDOM&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n### 例2：保存任何可变值\n\n在组件的整个生命周期保持不变，类似于 class 的实例属性。这意味着可以用于保存之前某一刻的状态值，需要时恢复即可。\n\n```jsx\nimport React, { useRef, useState, useEffect } from 'react'\n\nexport default function UseRefDemo2() {\n  const [count, setCount] = useState(100)\n  const numRef = useRef(count)\n\n  // 在组件挂载时，保存初始 count 状态\n  useEffect(() =&gt; {\n    numRef.current = count\n  }, [])\n\n  return (\n    <div>\n      初始count：{numRef.current}\n      count本次的值：{count}\n      &lt;button onClick={ () =&gt; { setCount(count + 100) } }&gt;+100&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n## useImperativeHandle\n\n该 hook 用于控制子组件要将哪些东西暴露给向父组件。没有暴露的东西，父组件无权拿到、使用，达到权限控制的目的。\n\n一般建议使用，使程序更可控。\n\n参数：\n-   接收一个`ref`\n-   接收一个函数，**这个函数返回的对象即是要暴露出的`ref`**\n-   类似`useEffect`，接收一个依赖数组\n\n&gt; ref转发见：[React - Refs转发](React%20-%20Refs转发.md)\n\n### 例子\n\n```jsx\nimport React, { forwardRef, useRef, useImperativeHandle } from 'react'\n\nconst Input = forwardRef((props, ref) =&gt; {\n  const inputRef1 = useRef()\n  const inputRef2 = useRef()\n\n  useImperativeHandle(\n    ref,\n    () =&gt; ({\n      f: () =&gt; {\n        inputRef1.current.focus()\n      },\n      /* 更多 */\n    }),\n    [inputRef1],\n  )\n  return (\n    <div>\n      &lt;input ref={inputRef1} type=\"text\" /&gt;\n      <br />\n      &lt;input ref={inputRef2} type=\"text\" /&gt;\n    <div />\n  )\n})\n\nexport default function UseImperativeHandleDemo() {\n  const inputRef = useRef()\n  return (\n    <div>\n      &lt;Input ref={inputRef}&gt;&lt;/Input&gt;\n      &lt;button onClick={() =&gt; { inputRef.current.f() }}&gt;聚焦&lt;/button&gt;\n      {/* 这里只拿得到 useImperativeHandle 暴露的对象，\n      而不是 input1 元素，防止父组件随意的操作 DOM */}\n      &lt;button onClick={() =&gt; { console.log(inputRef.current); }}&gt;打印&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n上面例子仅暴露了 `useImperativeHandle` 第二个参数（函数）返会的对象，`input1` 元素本身并未暴露，`inputRef2` 也为暴露，达到权限控住目的。第三个参数意思是：`inputRef1` 变化时更新这个挂载。\n\n点击\"聚焦\" button 成功聚焦 `input1` ，点击“打印” button 会打印：\n\n```js\n{\n  f: () =&gt; {\n    inputRef1.current.focus()\n  }\n}\n```\n\n## useLayoutEffect\n\n`useLayoutEffect` 和 `useEffet` 的唯一区别就是：\n\n- `useLayoutEffect` 在更新真实 DOM 前操作，会阻塞页面渲染。\n- `useEffect` 在真实 DOM 更新之后才操作，不会阻塞页面渲染。\n\n一般情况下都使用 `useEffect`，只有特殊情况才使用 `useLayoutEffect`。\n\n### 例子：防止页面闪烁\n\n计数器案例：点击 改变 count 后，又通过不同方式再改变 count。\n\n`useEffect` 方式：页面二次渲染。\n\n```jsx\nimport React, { useState, useEffect } from 'react'\n\nexport default function EffectCounterDemo() {\n  const [count, setCount] = useState(10)\n\n  useEffect(() =&gt; {\n    if(count === 0) {\n      setCount(Math.random() + 200)\n    }\n  }, [count])\n\n  return (\n    <div>\n      {count}\n      {/* \n        点击可以发现有个明显的闪烁。\n        这是因为 useEffect 是在 DOM 更新完毕后才执行，\n        count 又被更新，页面二次渲染导致。\n       */}\n      &lt;button onClick={() =&gt; { setCount(0) }}&gt;改变count&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n`useLayoutEffect` 方式，合并 count 为最新值不会二次渲染。\n\n```jsx\nimport React, { useState, useLayoutEffect } from 'react'\n\nexport default function LayoutEffectCounterDemo() {\n  const [count, setCount] = useState(10)\n\t\n  // 在真实 DOM 更新前执行，使得 count 已经覆盖为最新的值了，\n  // 不会导致页面二次渲染\n  useLayoutEffect(() =&gt; {\n    if(count === 0) {\n      setCount(Math.random() + 200)\n    }\n  }, [count])\n\n  return (\n    <div>\n      {count}\n      &lt;button onClick={() =&gt; { setCount(0) }}&gt;改变count&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n"},{"id":49,"time":1651881461532,"title":"React - Hook","intro":"介绍官方提供的几个 react hook","content":"# React - Hook\n\n#计算机/web/react \n\n## Hook 简介\n\nHook 是 React 16.8 引入的新特性。\n\n它使我们能够不用编写 Class 组件，采用 **函数式组件 + hook** 的方式完成开发（hook 用于管理 state、模拟生命周期方法…）。\n\n优势：\n\n- 极大地简洁了代码\n\n- 无需使用 `this`（在大型项目中判断 `this` 是谁需要付出额外的心智负担）。\n\n## 使用规则\n\nHook 就是 JavaScript 函数，使用它们需要准守两个规则：\n\n- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。\n- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（[React - 自定义Hook](React%20-%20自定义Hook.md)例外）\n\n## 基本使用\n\n这里用一个计数器案例来演示 “函数式组件 + hook” 的简洁性\n\n```jsx\nimport {React, useState} from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <div>当前技术: { count }</div>\n      &lt;button&gt;+1&lt;/button&gt;\n      &lt;button onClick={e =&gt; setCount(count - 1)}&gt;-1&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n对比 class 方式它非常的简洁易读！\n\n## useState\n\n基本和 class 组件的 state 相同。\n\n对于 `const [names, setNames] = useState(['小红', '小白'])`：\n\n- names 为该状态的变量名。\n- setNames 用于更新状态。\n- useState 的参数为变量的默认值，可以是有返回值的函数，可为空。\n\n&gt; React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\n\n上面这段话的意思就是：`setState` 不会因为组件重新渲染而重新创建（内存地址不变）。你把`setState` 传给其它组件（memo 包裹），浅层对比一样，不会导致其重新渲染。\n\n### 例1：管理多个状态\n\n可以编写多个 `useState` 管理多个状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function MultiHookState() {\n  const [names, setNames] = useState(['小红', '小白'])\n  const [age, setAge] = useState(18)\n  return (\n    <div>\n      <ul>\n        {age}\n        {\n          names.map((item, index) =&gt; {\n            return <li>{item}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例2：管理复杂状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ComplexHookState() {\n  const [students, setStudents] = useState([\n    { id: 110, name: \"djs\", age: 18 },\n    { id: 111, name: \"kdls\", age: 33 },\n    { id: 112, name: \"ddd\", age: 15 },\n  ])\n\n  const incrementAgeWithIndex = (index) =&gt; {\n    let s = [...students]\n    s[index].age +=1\n    setStudents(s)\n  }\n  return (\n    <div>\n      <ul>\n        {\n          students.map((item, index) =&gt; {\n            return <li>\n              <span>姓名：{item.name}</span>\n              <span>年龄：{item.age}</span>\n              &lt;button onClick={() =&gt; { incrementAgeWithIndex(index) }}&gt;\n                年龄+1\n              &lt;/button&gt;\n            </li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例3：useState 参数可以是函数\n\n需要有返回值，作为其默认值。\n\n```jsx\nconst [todos, setTodos] = useState(() =&gt; {\n  // 读取本地存储\n  return JSON.parse(window.localStorage.getItem('todos'))\n})\n```\n\n### 例4：set 函数的参数可以为函数\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ParameterCanBeAFunction() {\n  const [count, setCount] = useState(10)\n  const handleCount = () =&gt; {\n    // 以下连续操作会被合并，只会加1。类似 setState({})\n    // setcount(count + 1)\n    // setcount(count + 1)\n    // setcount(count + 1)\n\n    // 使用前一个状态进行累加\n    setCount((prevCount) =&gt; (prevCount + 1))\n    setCount((prevCount) =&gt; (prevCount + 1))\n    setCount((prevCount) =&gt; (prevCount + 1))\n  }\n  return (\n    <div>\n      { count }\n      &lt;button onClick={handleCount}&gt;累加的方式 +3&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n## useEffect\n\n用该 hook 来模拟 class 组件的生命周期方法：`componentDidMount`、 `componentDidUpdate`、 `componentWillUnmount`。\n\n&gt; 参考：[React - 组件的生命周期](React%20-%20组件的生命周期.md)。\n\n### 例1：随着状态更新网页 titile\n\n```jsx\nimport React, { useEffect, useState } from 'react'\n\nexport default function TitleWithDataUpdate() {\n  const [count, setCount] = useState(0)\n  useEffect(() =&gt; {\n    document.title = '当前计数' + count\n  })\n  return (\n    <div>\n      {count}\n      &lt;button onClick={() =&gt; { setCount(count + 1) }}&gt;+1&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n&gt; 相当于使用了 class 组件的 `componentDidMount` （初始更新 title）和 `componentDidUpdate` （状态改变更新 title）\n\n### 例2：模拟订阅与取消订阅\n\n`useEffect` 在不带第二参数的情况下:\n\n- 第一次渲染和之后的每次组件重新渲染，都会重新调用 `useEffect`。这在某些情况下有助于减少BUG（如：数据更新，需要先清理原来事件，再重新订阅）\n\n- 这种情况每次返回的都是一个新的 `useEffect` 函数。\n\n```jsx\nimport React, { useEffect, useState } from 'react'\n\nexport default function EffectHookCancelDemo() {\n  const [count, setCount] = useState(0)\n  useEffect(() =&gt; {\n    console.log('DOM更新后 订阅事件,或其他操作')\n    return () =&gt; {\n      console.log('DOM移除后 取消事件')\n    }\n  })\n}\n```\n\n### 例3：初次渲染订阅事件，组件卸载取消订阅\n\n如果只想在组件创建时订阅事件，组件卸载时取消订阅，可以带第二参数`[]`。\n\n```jsx\nuseEffect(() =&gt; {\n  console.log('DOM更新后 订阅事件')\n  return () =&gt; {\n    console.log('DOM移除后 取消事件')\n  }\n}, [])\n```\n\n&gt; 上面例子类似于 class 组件的： `componentDidMount` 和 `componentWillUnmount` 。\n\n### 例4：性能优化，在依赖状态变化时才重新执行 `useEffect `\n\n下面例子初次渲染会订阅事件，在 userID 变化时才重新执行 `useEffect `（取消事件，重新订阅）。\n\n```jsx\nuseEffect(() =&gt; {\n  console.log('DOM更新后 订阅事件')\n  return () =&gt; {\n    console.log('DOM移除后 取消事件')\n  }\n}, [userID])\n```\n\n### 例5：多个 useEffect 同时使用\n\n```jsx\n// 以下 useEffect 会依次执行,这样做以实现逻辑分离。\nuseEffect(() =&gt; {\n  console.log('网络请求')\n})\n\nuseEffect(() =&gt; {\n  console.log('修改DOM')\n})\n\nuseEffect(() =&gt; {\n  console.log('订阅事件')\n  return () =&gt; {\n    console.log('取消事件')\n  }\n})\n```\n\n## useContext\n\n[Context Consumer](React%20-%20context%20向后代组件共享数据.md#Context%20Consumer)：←该笔记演示了两组 context 消费组件的使用方法，如果是5组 context 呢？那嵌套可就麻烦了。\n\nuseContext 就是为了解决 context 消费组件嵌套地狱的问题。\n\n### 例子\n\n提供组件\n\n```jsx\n// 需要导出 Context\nexport const ThemeContext = React.createContext({ background: \"#ddd\" })\nexport const UserDataContext = React.createContext({ name: '无', age: 0 })\n\nexport default function App() {\n  return (\n    <div>\n      &lt;ThemeContext.Provider value={{ background: \"#eeeeee\" }}&gt;\n        &lt;UserDataContext.Provider value={{ name: \"小明\", age: 18 }}&gt;\n          &lt;UseOfUseContext /&gt;\n        &lt;/UserDataContext.Provider&gt;\n      &lt;/ThemeContext.Provider&gt;\n    </div>\n  )\n}\n```\n\n消费组件\n\n```jsx\nimport React, { useContext } from 'react'\n// 导入 Context\nimport { ThemeContext, UserDataContext } from '../App'\n\nexport default function UseOfUseContext() {\n  // 拿到数据\n  const theme = useContext(ThemeContext)\n  const userData = useContext(UserDataContext)\n  return (\n    <div>\n      用户名：{ userData.name }|\n      年龄：{ userData.age }\n    </div>\n  )\n}\n```\n\n上方代码可见无需嵌套即可拿到数据，简洁很多。\n\n## useReducer\n\n`useReducer` 是 `useState` 的替代品，并不是用来替代 Redux 的。\n\n它不会组件间共享数据，即使引用的是同一个 `reducer`，但用法类似于 [Redux](React%20-%20Redux%201.%E5%88%9D%E6%8E%A2.md) 的 `reducer` 函数。\n\n使用场景：`useState` 逻辑太复杂需要拆分任务时。\n\n### 例子\n\n先编写 reducer.js \n\n```jsx\nexport default (state, action) =&gt; {\n  switch(action.type) {\n    case 'increment':\n      return { ...state, count: state.count + 1 }\n    case 'decrement':\n      return { ...state, count: state.count - 1 }\n    default:\n      return state\n  }\n}\n```\n\n在 home1.js 中使用\n\n```jsx\nimport React, { useReducer } from 'react'\n// 导入\nimport reducer from './reducer'\n\nexport default function Home1() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 })\n  return (\n    <div>\n      home1当前数字：{state.count}\n      &lt;button onClick={() =&gt; { dispatch({ type: 'increment' }) }}&gt;\n        +1\n      &lt;/button&gt;\n    </div>\n  )\n}\n```\n\n为了演示不会共享 reducer ，在 home2.js 中引入同一个 reducer\n\n```jsx\nimport React, { useReducer } from 'react'\n\nimport reducer from './reducer'\n\nexport default function Home2() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 })\n  return (\n    <div>\n      home2当前数字：{state.count}\n      &lt;button onClick={() =&gt; { dispatch({ type: 'increment' }) }}&gt;+1&lt;/button&gt;\n    </div>\n  )\n```\n\n通过演示可以发现，它们的数据是独立存储的。\n\n## useCallback\n\n用于性能优化。\n\n在依赖 state 没变时，返回同一个函数（相同内存地址）。\n\n```jsx\n// count 只要不变，即使当前组件重新渲染也返回同一个函数。\nconst s = useCallback(\n  () =&gt; {\n    setCount(count + 1)\n  },\n  [count]\n)\n```\n\n利用该特性，在传递回调函数给子组件时，可以避免不必要的重新 render（对于函数组件，配合 `memo`）。\n\n- 普通函数即使使用了 `memo` 但是浅层比较时函数已经变了（内存地址不同），会导致重新 render 浪费性能。\n\n- 使用了 useCallback 的组件只要依赖状态不变，就会返回相同的函数，正确跳过不必要的渲染。\n\n### 例子\n\n```jsx\nimport React, { useState, useCallback, memo } from 'react'\n\n// memo 只进行浅层比较（对比函数内存地址），\n// 没有变就不会重新 render。\nconst CounterButton = memo((props) =&gt; {\n  console.log(props.name);\n  return &lt;button onClick={props.increment}&gt;+1&lt;/button&gt;\n})\n\n\nexport default function CorrectUsecallback() {\n  const [count, setCount] = useState(0)\n  const [show, setShow] = useState(true)\n  \n  // 第二参数为空，总是返回同一个函数\n  const increment1 = useCallback(\n    () =&gt; {\n      setCount(count + 1)\n    },\n    []\n  )\n  // 本组件重新 render 时，这里会重新创建函数\n  const increment2 = () =&gt; {\n    setCount(count + 1)\n  }\n  return (\n    <div>\n      {count}\n      &lt;CounterButton increment={increment1} name='性能优化'&gt;&lt;/CounterButton&gt;\n      &lt;CounterButton increment={increment2} name='未性能优化'&gt;&lt;/CounterButton&gt;\n      {/* 切换show会导致本组件重新渲染 */}\n      &lt;button onClick={ () =&gt; { setShow(!show) } }&gt;切换show&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n## useMemo\n\n用于性能优化。\n\n在依赖 state 不变的情况下，返回“记忆值”。\n\n应用场景：\n\n- 对于复杂计算。只要依赖不变，直接返回计算结果，而不必在每次重新 render 时都计算一遍。（有点像 vue 的计算属性。）\n- 对于引用类型，传递给子组件使用。保证即使重新 render 只要依赖不变都返回同一个对象，子组件配合 `memo` 以正确跳过不必要的 render。\n\n### 例1：复杂计算缓存结果\n\n```jsx\nimport React, { useState, useMemo } from 'react'\n// 计算阶乘的函数\nconst factorial = (n) =&gt; {\n  if(n &lt;= 1) return 1\n  return n * factorial(n - 1)\n}\n\nexport default function UseMemoDemo1() {\n  const [count, setCount] = useState(15)\n  const [show, setShow] = useState(true)\n  // 在count没有发生改变时，直接返回缓存的结果，以节约性能\n  const result = useMemo(() =&gt; {\n    console.log('计算阶乘结果中');\n    return factorial(count)\n  }, [count])\n\n  return (\n    <div>\n      {count}的阶乘：{result}\n      &lt;button onClick={() =&gt; { setCount(count + 1) }}&gt;+1&lt;/button&gt;\n      {/* 切换show会导致本组件重新渲染，已验证是否重新计算 */}\n      &lt;button onClick={() =&gt; { setShow(!show) }}&gt;切换show&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n### 例2：向子组件传入引用类型\n\n```jsx\nimport React, { useState, useMemo, memo } from 'react'\n\nconst MyInfo = memo((props) =&gt; {\n  console.log(`${props.info.name}render`);\n  return (\n    <div>\n      {props.info.name}\n      {props.info.age}\n    </div>\n  )\n})\n\nexport default function UseMemoDemo1() {\n  const [show, setShow] = useState(true)\n\n  const info1 = useMemo(() =&gt; {\n    return { name: '小明', age: 18 }\n  }, [])\n\n  const info2 = { name: '小红', age: 18 }\n  \n  return (\n    <div>\n      {/* 切换show会导致本组件重新渲染 */}\n      &lt;button onClick={() =&gt; { setShow(!show) }}&gt;切换show&lt;/button&gt;\n\n      {/* 点击上面按钮可以发现，\n          使用了 useMemo 的 小明组件 没有重新 render，\n          这是因为当前组件重新 render 时，\n          info1 返回的是同一个对象内存地址，\n          info2 重新指向了一个新的内存地址，\n          MyInfo 中使用 memo 进行浅层比较，自然不会更新 小明组件。\n      */}\n      &lt;MyInfo info={info1}&gt;&lt;/MyInfo&gt;\n      &lt;MyInfo info={info2}&gt;&lt;/MyInfo&gt;\n    </div>\n  )\n}\n```\n\n## useRef\n\n返回一个 ref 对象，返回的对象在组件的整个生命周期保持不变。\n\n### 例1：引入DOM/class组件实例\n\n```jsx\nimport React, { useRef } from 'react'\n\nclass T1 extends React.PureComponent {\n  render() {\n    return <h2>T1</h2>\n  }\n}\n\nexport default function UseRefDemo1() {\n  const inputRef = useRef()\n  const t1Ref = useRef()\n\n  const changeDOM = () =&gt; {\n    inputRef.current.focus()\n    console.log(t1Ref)\n  }\n\n  return (\n    <div>\n      &lt;input ref={inputRef} type=\"text\"/&gt;\n      &lt;T1 ref={t1Ref}&gt;&lt;/T1&gt;\n      &lt;button onClick={changeDOM}&gt;changeDOM&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n### 例2：保存任何可变值\n\n在组件的整个生命周期保持不变，类似于 class 的实例属性。这意味着可以用于保存之前某一刻的状态值，需要时恢复即可。\n\n```jsx\nimport React, { useRef, useState, useEffect } from 'react'\n\nexport default function UseRefDemo2() {\n  const [count, setCount] = useState(100)\n  const numRef = useRef(count)\n\n  // 在组件挂载时，保存初始 count 状态\n  useEffect(() =&gt; {\n    numRef.current = count\n  }, [])\n\n  return (\n    <div>\n      初始count：{numRef.current}\n      count本次的值：{count}\n      &lt;button onClick={ () =&gt; { setCount(count + 100) } }&gt;+100&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n## useImperativeHandle\n\n该 hook 用于控制子组件要将哪些东西暴露给向父组件。没有暴露的东西，父组件无权拿到、使用，达到权限控制的目的。\n\n一般建议使用，使程序更可控。\n\n参数：\n-   接收一个`ref`\n-   接收一个函数，**这个函数返回的对象即是要暴露出的`ref`**\n-   类似`useEffect`，接收一个依赖数组\n\n&gt; ref转发见：[React - Refs转发](React%20-%20Refs转发.md)\n\n### 例子\n\n```jsx\nimport React, { forwardRef, useRef, useImperativeHandle } from 'react'\n\nconst Input = forwardRef((props, ref) =&gt; {\n  const inputRef1 = useRef()\n  const inputRef2 = useRef()\n\n  useImperativeHandle(\n    ref,\n    () =&gt; ({\n      f: () =&gt; {\n        inputRef1.current.focus()\n      },\n      /* 更多 */\n    }),\n    [inputRef1],\n  )\n  return (\n    <div>\n      &lt;input ref={inputRef1} type=\"text\" /&gt;\n      <br />\n      &lt;input ref={inputRef2} type=\"text\" /&gt;\n    <div />\n  )\n})\n\nexport default function UseImperativeHandleDemo() {\n  const inputRef = useRef()\n  return (\n    <div>\n      &lt;Input ref={inputRef}&gt;&lt;/Input&gt;\n      &lt;button onClick={() =&gt; { inputRef.current.f() }}&gt;聚焦&lt;/button&gt;\n      {/* 这里只拿得到 useImperativeHandle 暴露的对象，\n      而不是 input1 元素，防止父组件随意的操作 DOM */}\n      &lt;button onClick={() =&gt; { console.log(inputRef.current); }}&gt;打印&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n上面例子仅暴露了 `useImperativeHandle` 第二个参数（函数）返会的对象，`input1` 元素本身并未暴露，`inputRef2` 也为暴露，达到权限控住目的。第三个参数意思是：`inputRef1` 变化时更新这个挂载。\n\n点击\"聚焦\" button 成功聚焦 `input1` ，点击“打印” button 会打印：\n\n```js\n{\n  f: () =&gt; {\n    inputRef1.current.focus()\n  }\n}\n```\n\n## useLayoutEffect\n\n`useLayoutEffect` 和 `useEffet` 的唯一区别就是：\n\n- `useLayoutEffect` 在更新真实 DOM 前操作，会阻塞页面渲染。\n- `useEffect` 在真实 DOM 更新之后才操作，不会阻塞页面渲染。\n\n一般情况下都使用 `useEffect`，只有特殊情况才使用 `useLayoutEffect`。\n\n### 例子：防止页面闪烁\n\n计数器案例：点击 改变 count 后，又通过不同方式再改变 count。\n\n`useEffect` 方式：页面二次渲染。\n\n```jsx\nimport React, { useState, useEffect } from 'react'\n\nexport default function EffectCounterDemo() {\n  const [count, setCount] = useState(10)\n\n  useEffect(() =&gt; {\n    if(count === 0) {\n      setCount(Math.random() + 200)\n    }\n  }, [count])\n\n  return (\n    <div>\n      {count}\n      {/* \n        点击可以发现有个明显的闪烁。\n        这是因为 useEffect 是在 DOM 更新完毕后才执行，\n        count 又被更新，页面二次渲染导致。\n       */}\n      &lt;button onClick={() =&gt; { setCount(0) }}&gt;改变count&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n`useLayoutEffect` 方式，合并 count 为最新值不会二次渲染。\n\n```jsx\nimport React, { useState, useLayoutEffect } from 'react'\n\nexport default function LayoutEffectCounterDemo() {\n  const [count, setCount] = useState(10)\n\t\n  // 在真实 DOM 更新前执行，使得 count 已经覆盖为最新的值了，\n  // 不会导致页面二次渲染\n  useLayoutEffect(() =&gt; {\n    if(count === 0) {\n      setCount(Math.random() + 200)\n    }\n  }, [count])\n\n  return (\n    <div>\n      {count}\n      &lt;button onClick={() =&gt; { setCount(0) }}&gt;改变count&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n"},{"id":50,"time":1651892136135,"title":"React - Hook","intro":"介绍官方提供的几个 react hook","content":"# React - Hook\n\n#计算机/web/react \n\n## Hook 简介\n\nHook 是 React 16.8 引入的新特性。\n\n它使我们能够不用编写 Class 组件，采用 **函数式组件 + hook** 的方式完成开发（hook 用于管理 state、模拟生命周期方法…）。\n\n优势：\n\n- 极大地简洁了代码\n\n- 无需使用 `this`（在大型项目中判断 `this` 是谁需要付出额外的心智负担）。\n\n## 使用规则\n\nHook 就是 JavaScript 函数，使用它们需要准守两个规则：\n\n- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。\n- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（[React - 自定义Hook](React%20-%20自定义Hook.md)例外）\n\n## 基本使用\n\n这里用一个计数器案例来演示 “函数式组件 + hook” 的简洁性\n\n```jsx\n<img src>\nimport {React, useState} from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <div>当前技术: { count }</div>\n      &lt;button onClick={e =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;\n      &lt;button onClick={e =&gt; setCount(count - 1)}&gt;-1&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n对比 class 方式它非常的简洁易读！\n\n## useState\n\n基本和 class 组件的 state 相同。\n\n对于 `const [names, setNames] = useState(['小红', '小白'])`：\n\n- names 为该状态的变量名。\n- setNames 用于更新状态。\n- useState 的参数为变量的默认值，可以是有返回值的函数，可为空。\n\n&gt; React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\n\n上面这段话的意思就是：`setState` 不会因为组件重新渲染而重新创建（内存地址不变）。你把`setState` 传给其它组件（memo 包裹），浅层对比一样，不会导致其重新渲染。\n\n### 例1：管理多个状态\n\n可以编写多个 `useState` 管理多个状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function MultiHookState() {\n  const [names, setNames] = useState(['小红', '小白'])\n  const [age, setAge] = useState(18)\n  return (\n    <div>\n      <ul>\n        {age}\n        {\n          names.map((item, index) =&gt; {\n            return <li>{item}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例2：管理复杂状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ComplexHookState() {\n  const [students, setStudents] = useState([\n    { id: 110, name: \"djs\", age: 18 },\n    { id: 111, name: \"kdls\", age: 33 },\n    { id: 112, name: \"ddd\", age: 15 },\n  ])\n\n  const incrementAgeWithIndex = (index) =&gt; {\n    let s = [...students]\n    s[index].age +=1\n    setStudents(s)\n  }\n  return (\n    <div>\n      <ul>\n        {\n          students.map((item, index) =&gt; {\n            return <li>\n              <span>姓名：{item.name}</span>\n              <span>年龄：{item.age}</span>\n              &lt;button onClick={() =&gt; { incrementAgeWithIndex(index) }}&gt;\n                年龄+1\n              &lt;/button&gt;\n            </li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例3：useState 参数可以是函数\n\n需要有返回值，作为其默认值。\n\n```jsx\nconst [todos, setTodos] = useState(() =&gt; {\n  // 读取本地存储\n  return JSON.parse(window.localStorage.getItem('todos'))\n})\n```\n\n### 例4：set 函数的参数可以为函数\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ParameterCanBeAFunction() {\n  const [count, setCount] = useState(10)\n  const handleCount = () =&gt; {\n    // 以下连续操作会被合并，只会加1。类似 setState({})\n    // setcount(count + 1)\n    // setcount(count + 1)\n    // setcount(count + 1)\n\n    // 使用前一个状态进行累加\n    setCount((prevCount) =&gt; (prevCount + 1))\n    setCount((prevCount) =&gt; (prevCount + 1))\n    setCount((prevCount) =&gt; (prevCount + 1))\n  }\n  return (\n    <div>\n      { count }\n      &lt;button onClick={handleCount}&gt;累加的方式 +3&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n## useEffect\n\n用该 hook 来模拟 class 组件的生命周期方法：`componentDidMount`、 `componentDidUpdate`、 `componentWillUnmount`。\n\n&gt; 参考：[React - 组件的生命周期](React%20-%20组件的生命周期.md)。\n\n### 例1：随着状态更新网页 titile\n\n```jsx\nimport React, { useEffect, useState } from 'react'\n\nexport default function TitleWithDataUpdate() {\n  const [count, setCount] = useState(0)\n  useEffect(() =&gt; {\n    document.title = '当前计数' + count\n  })\n  return (\n    <div>\n      {count}\n      &lt;button onClick={() =&gt; { setCount(count + 1) }}&gt;+1&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n&gt; 相当于使用了 class 组件的 `componentDidMount` （初始更新 title）和 `componentDidUpdate` （状态改变更新 title）\n\n### 例2：模拟订阅与取消订阅\n\n`useEffect` 在不带第二参数的情况下:\n\n- 第一次渲染和之后的每次组件重新渲染，都会重新调用 `useEffect`。这在某些情况下有助于减少BUG（如：数据更新，需要先清理原来事件，再重新订阅）\n\n- 这种情况每次返回的都是一个新的 `useEffect` 函数。\n\n```jsx\nimport React, { useEffect, useState } from 'react'\n\nexport default function EffectHookCancelDemo() {\n  const [count, setCount] = useState(0)\n  useEffect(() =&gt; {\n    console.log('DOM更新后 订阅事件,或其他操作')\n    return () =&gt; {\n      console.log('DOM移除后 取消事件')\n    }\n  })\n}\n```\n\n### 例3：初次渲染订阅事件，组件卸载取消订阅\n\n如果只想在组件创建时订阅事件，组件卸载时取消订阅，可以带第二参数`[]`。\n\n```jsx\nuseEffect(() =&gt; {\n  console.log('DOM更新后 订阅事件')\n  return () =&gt; {\n    console.log('DOM移除后 取消事件')\n  }\n}, [])\n```\n\n&gt; 上面例子类似于 class 组件的： `componentDidMount` 和 `componentWillUnmount` 。\n\n### 例4：性能优化，在依赖状态变化时才重新执行 `useEffect `\n\n下面例子初次渲染会订阅事件，在 userID 变化时才重新执行 `useEffect `（取消事件，重新订阅）。\n\n```jsx\nuseEffect(() =&gt; {\n  console.log('DOM更新后 订阅事件')\n  return () =&gt; {\n    console.log('DOM移除后 取消事件')\n  }\n}, [userID])\n```\n\n### 例5：多个 useEffect 同时使用\n\n```jsx\n// 以下 useEffect 会依次执行,这样做以实现逻辑分离。\nuseEffect(() =&gt; {\n  console.log('网络请求')\n})\n\nuseEffect(() =&gt; {\n  console.log('修改DOM')\n})\n\nuseEffect(() =&gt; {\n  console.log('订阅事件')\n  return () =&gt; {\n    console.log('取消事件')\n  }\n})\n```\n\n## useContext\n\n[Context Consumer](React%20-%20context%20向后代组件共享数据.md#Context%20Consumer)：←该笔记演示了两组 context 消费组件的使用方法，如果是5组 context 呢？那嵌套可就麻烦了。\n\nuseContext 就是为了解决 context 消费组件嵌套地狱的问题。\n\n### 例子\n\n提供组件\n\n```jsx\n// 需要导出 Context\nexport const ThemeContext = React.createContext({ background: \"#ddd\" })\nexport const UserDataContext = React.createContext({ name: '无', age: 0 })\n\nexport default function App() {\n  return (\n    <div>\n      &lt;ThemeContext.Provider value={{ background: \"#eeeeee\" }}&gt;\n        &lt;UserDataContext.Provider value={{ name: \"小明\", age: 18 }}&gt;\n          &lt;UseOfUseContext /&gt;\n        &lt;/UserDataContext.Provider&gt;\n      &lt;/ThemeContext.Provider&gt;\n    </div>\n  )\n}\n```\n\n消费组件\n\n```jsx\nimport React, { useContext } from 'react'\n// 导入 Context\nimport { ThemeContext, UserDataContext } from '../App'\n\nexport default function UseOfUseContext() {\n  // 拿到数据\n  const theme = useContext(ThemeContext)\n  const userData = useContext(UserDataContext)\n  return (\n    <div>\n      用户名：{ userData.name }|\n      年龄：{ userData.age }\n    </div>\n  )\n}\n```\n\n上方代码可见无需嵌套即可拿到数据，简洁很多。\n\n## useReducer\n\n`useReducer` 是 `useState` 的替代品，并不是用来替代 Redux 的。\n\n它不会组件间共享数据，即使引用的是同一个 `reducer`，但用法类似于 [Redux](React%20-%20Redux%201.%E5%88%9D%E6%8E%A2.md) 的 `reducer` 函数。\n\n使用场景：`useState` 逻辑太复杂需要拆分任务时。\n\n### 例子\n\n先编写 reducer.js \n\n```jsx\nexport default (state, action) =&gt; {\n  switch(action.type) {\n    case 'increment':\n      return { ...state, count: state.count + 1 }\n    case 'decrement':\n      return { ...state, count: state.count - 1 }\n    default:\n      return state\n  }\n}\n```\n\n在 home1.js 中使用\n\n```jsx\nimport React, { useReducer } from 'react'\n// 导入\nimport reducer from './reducer'\n\nexport default function Home1() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 })\n  return (\n    <div>\n      home1当前数字：{state.count}\n      &lt;button onClick={() =&gt; { dispatch({ type: 'increment' }) }}&gt;\n        +1\n      &lt;/button&gt;\n    </div>\n  )\n}\n```\n\n为了演示不会共享 reducer ，在 home2.js 中引入同一个 reducer\n\n```jsx\nimport React, { useReducer } from 'react'\n\nimport reducer from './reducer'\n\nexport default function Home2() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 })\n  return (\n    <div>\n      home2当前数字：{state.count}\n      &lt;button onClick={() =&gt; { dispatch({ type: 'increment' }) }}&gt;+1&lt;/button&gt;\n    </div>\n  )\n```\n\n通过演示可以发现，它们的数据是独立存储的。\n\n## useCallback\n\n用于性能优化。\n\n在依赖 state 没变时，返回同一个函数（相同内存地址）。\n\n```jsx\n// count 只要不变，即使当前组件重新渲染也返回同一个函数。\nconst s = useCallback(\n  () =&gt; {\n    setCount(count + 1)\n  },\n  [count]\n)\n```\n\n利用该特性，在传递回调函数给子组件时，可以避免不必要的重新 render（对于函数组件，配合 `memo`）。\n\n- 普通函数即使使用了 `memo` 但是浅层比较时函数已经变了（内存地址不同），会导致重新 render 浪费性能。\n\n- 使用了 useCallback 的组件只要依赖状态不变，就会返回相同的函数，正确跳过不必要的渲染。\n\n### 例子\n\n```jsx\nimport React, { useState, useCallback, memo } from 'react'\n\n// memo 只进行浅层比较（对比函数内存地址），\n// 没有变就不会重新 render。\nconst CounterButton = memo((props) =&gt; {\n  console.log(props.name);\n  return &lt;button onClick={props.increment}&gt;+1&lt;/button&gt;\n})\n\n\nexport default function CorrectUsecallback() {\n  const [count, setCount] = useState(0)\n  const [show, setShow] = useState(true)\n  \n  // 第二参数为空，总是返回同一个函数\n  const increment1 = useCallback(\n    () =&gt; {\n      setCount(count + 1)\n    },\n    []\n  )\n  // 本组件重新 render 时，这里会重新创建函数\n  const increment2 = () =&gt; {\n    setCount(count + 1)\n  }\n  return (\n    <div>\n      {count}\n      &lt;CounterButton increment={increment1} name='性能优化'&gt;&lt;/CounterButton&gt;\n      &lt;CounterButton increment={increment2} name='未性能优化'&gt;&lt;/CounterButton&gt;\n      {/* 切换show会导致本组件重新渲染 */}\n      &lt;button onClick={ () =&gt; { setShow(!show) } }&gt;切换show&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n## useMemo\n\n用于性能优化。\n\n在依赖 state 不变的情况下，返回“记忆值”。\n\n应用场景：\n\n- 对于复杂计算。只要依赖不变，直接返回计算结果，而不必在每次重新 render 时都计算一遍。（有点像 vue 的计算属性。）\n- 对于引用类型，传递给子组件使用。保证即使重新 render 只要依赖不变都返回同一个对象，子组件配合 `memo` 以正确跳过不必要的 render。\n\n### 例1：复杂计算缓存结果\n\n```jsx\nimport React, { useState, useMemo } from 'react'\n// 计算阶乘的函数\nconst factorial = (n) =&gt; {\n  if(n &lt;= 1) return 1\n  return n * factorial(n - 1)\n}\n\nexport default function UseMemoDemo1() {\n  const [count, setCount] = useState(15)\n  const [show, setShow] = useState(true)\n  // 在count没有发生改变时，直接返回缓存的结果，以节约性能\n  const result = useMemo(() =&gt; {\n    console.log('计算阶乘结果中');\n    return factorial(count)\n  }, [count])\n\n  return (\n    <div>\n      {count}的阶乘：{result}\n      &lt;button onClick={() =&gt; { setCount(count + 1) }}&gt;+1&lt;/button&gt;\n      {/* 切换show会导致本组件重新渲染，已验证是否重新计算 */}\n      &lt;button onClick={() =&gt; { setShow(!show) }}&gt;切换show&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n### 例2：向子组件传入引用类型\n\n```jsx\nimport React, { useState, useMemo, memo } from 'react'\n\nconst MyInfo = memo((props) =&gt; {\n  console.log(`${props.info.name}render`);\n  return (\n    <div>\n      {props.info.name}\n      {props.info.age}\n    </div>\n  )\n})\n\nexport default function UseMemoDemo1() {\n  const [show, setShow] = useState(true)\n\n  const info1 = useMemo(() =&gt; {\n    return { name: '小明', age: 18 }\n  }, [])\n\n  const info2 = { name: '小红', age: 18 }\n  \n  return (\n    <div>\n      {/* 切换show会导致本组件重新渲染 */}\n      &lt;button onClick={() =&gt; { setShow(!show) }}&gt;切换show&lt;/button&gt;\n\n      {/* 点击上面按钮可以发现，\n          使用了 useMemo 的 小明组件 没有重新 render，\n          这是因为当前组件重新 render 时，\n          info1 返回的是同一个对象内存地址，\n          info2 重新指向了一个新的内存地址，\n          MyInfo 中使用 memo 进行浅层比较，自然不会更新 小明组件。\n      */}\n      &lt;MyInfo info={info1}&gt;&lt;/MyInfo&gt;\n      &lt;MyInfo info={info2}&gt;&lt;/MyInfo&gt;\n    </div>\n  )\n}\n```\n\n## useRef\n\n返回一个 ref 对象，返回的对象在组件的整个生命周期保持不变。\n\n### 例1：引入DOM/class组件实例\n\n```jsx\nimport React, { useRef } from 'react'\n\nclass T1 extends React.PureComponent {\n  render() {\n    return <h2>T1</h2>\n  }\n}\n\nexport default function UseRefDemo1() {\n  const inputRef = useRef()\n  const t1Ref = useRef()\n\n  const changeDOM = () =&gt; {\n    inputRef.current.focus()\n    console.log(t1Ref)\n  }\n\n  return (\n    <div>\n      &lt;input ref={inputRef} type=\"text\"/&gt;\n      &lt;T1 ref={t1Ref}&gt;&lt;/T1&gt;\n      &lt;button onClick={changeDOM}&gt;changeDOM&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n### 例2：保存任何可变值\n\n在组件的整个生命周期保持不变，类似于 class 的实例属性。这意味着可以用于保存之前某一刻的状态值，需要时恢复即可。\n\n```jsx\nimport React, { useRef, useState, useEffect } from 'react'\n\nexport default function UseRefDemo2() {\n  const [count, setCount] = useState(100)\n  const numRef = useRef(count)\n\n  // 在组件挂载时，保存初始 count 状态\n  useEffect(() =&gt; {\n    numRef.current = count\n  }, [])\n\n  return (\n    <div>\n      初始count：{numRef.current}\n      count本次的值：{count}\n      &lt;button onClick={ () =&gt; { setCount(count + 100) } }&gt;+100&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n## useImperativeHandle\n\n该 hook 用于控制子组件要将哪些东西暴露给向父组件。没有暴露的东西，父组件无权拿到、使用，达到权限控制的目的。\n\n一般建议使用，使程序更可控。\n\n参数：\n-   接收一个`ref`\n-   接收一个函数，**这个函数返回的对象即是要暴露出的`ref`**\n-   类似`useEffect`，接收一个依赖数组\n\n&gt; ref转发见：[React - Refs转发](React%20-%20Refs转发.md)\n\n### 例子\n\n```jsx\nimport React, { forwardRef, useRef, useImperativeHandle } from 'react'\n\nconst Input = forwardRef((props, ref) =&gt; {\n  const inputRef1 = useRef()\n  const inputRef2 = useRef()\n\n  useImperativeHandle(\n    ref,\n    () =&gt; ({\n      f: () =&gt; {\n        inputRef1.current.focus()\n      },\n      /* 更多 */\n    }),\n    [inputRef1],\n  )\n  return (\n    <div&gt;>\n      &lt;input ref={inputRef1} type=\"text\" /&gt;\n      <br />\n      &lt;input ref={inputRef2} type=\"text\" /&gt;\n    <div />\n  )\n})\n\nexport default function UseImperativeHandleDemo() {\n  const inputRef = useRef()\n  return (\n    <div>\n      &lt;Input ref={inputRef}&gt;&lt;/Input&gt;\n      &lt;button onClick={() =&gt; { inputRef.current.f() }}&gt;聚焦&lt;/button&gt;\n      {/* 这里只拿得到 useImperativeHandle 暴露的对象，\n      而不是 input1 元素，防止父组件随意的操作 DOM */}\n      &lt;button onClick={() =&gt; { console.log(inputRef.current); }}&gt;打印&lt;/button&gt;\n    </div>\n  )\n}\n```\n\n上面例子仅暴露了 `useImperativeHandle` 第二个参数（函数）返会的对象，`input1` 元素本身并未暴露，`inputRef2` 也为暴露，达到权限控住目的。第三个参数意思是：`inputRef1` 变化时更新这个挂载。\n\n点击\"聚焦\" button 成功聚焦 `input1` ，点击“打印” button 会打印：\n\n```js\n{\n  f: () =&gt; {\n    inputRef1.current.focus()\n  }\n}\n```\n\n## useLayoutEffect\n\n`useLayoutEffect` 和 `useEffet` 的唯一区别就是：\n\n- `useLayoutEffect` 在更新真实 DOM 前操作，会阻塞页面渲染。\n- `useEffect` 在真实 DOM 更新之后才操作，不会阻塞页面渲染。\n\n一般情况下都使用 `useEffect`，只有特殊情况才使用 `useLayoutEffect`。\n\n### 例子：防止页面闪烁\n\n计数器案例：点击 改变 count 后，又通过不同方式再改变 count。\n\n`useEffect` 方式：页面二次渲染。\n\n```jsx\nimport React, { useState, useEffect } from 'react'\n\nexport default function EffectCounterDemo() {\n  const [count, setCount] = useState(10)\n\n  useEffect(() =&gt; {\n    if(count === 0) {\n      setCount(Math.random() + 200)\n    }\n  }, [count])\n\n  return (\n    <div>\n      {count}\n      {/* \n        点击可以发现有个明显的闪烁。\n        这是因为 useEffect 是在 DOM 更新完毕后才执行，\n        count 又被更新，页面二次渲染导致。\n       */}\n      &lt;button onClick={() =&gt; { setCount(0) }}&gt;改变count&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n`useLayoutEffect` 方式，合并 count 为最新值不会二次渲染。\n\n```jsx\nimport React, { useState, useLayoutEffect } from 'react'\n\nexport default function LayoutEffectCounterDemo() {\n  const [count, setCount] = useState(10)\n\t\n  // 在真实 DOM 更新前执行，使得 count 已经覆盖为最新的值了，\n  // 不会导致页面二次渲染\n  useLayoutEffect(() =&gt; {\n    if(count === 0) {\n      setCount(Math.random() + 200)\n    }\n  }, [count])\n\n  return (\n    <div>\n      {count}\n      &lt;button onClick={() =&gt; { setCount(0) }}&gt;改变count&lt;/button&gt;\n    </div>\n  )\n}\n\n```\n\n"},{"id":51,"time":1651892928338,"title":"React - Hook","intro":"介绍官方提供的几个 react hook","content":"# React - Hook\n\n#计算机/web/react \n\n## Hook 简介\n\nHook 是 React 16.8 引入的新特性。\n\n它使我们能够不用编写 Class 组件，采用 **函数式组件 + hook** 的方式完成开发（hook 用于管理 state、模拟生命周期方法…）。\n\n优势：\n\n- 极大地简洁了代码\n\n- 无需使用 `this`（在大型项目中判断 `this` 是谁需要付出额外的心智负担）。\n\n## 使用规则\n\nHook 就是 JavaScript 函数，使用它们需要准守两个规则：\n\n- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。\n- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（[React - 自定义Hook](React%20-%20自定义Hook.md)例外）\n\n## 基本使用\n\n这里用一个计数器案例来演示 “函数式组件 + hook” 的简洁性\n\n```jsx\nimport {React, useState} from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <div>当前技术: { count }</div>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n      <button onClick={e => setCount(count - 1)}>-1</button>\n    </div>\n  )\n}\n\n<script>alert('123')</script>\n<img src='-' onerror=alert(1);>\n```\n\n<script>alert('123')</script>\n<img src='-' onerror=alert(1);>\n\n对比 class 方式它非常的简洁易读！\n\n## useState\n\n基本和 class 组件的 state 相同。\n\n对于 `const [names, setNames] = useState(['小红', '小白'])`：\n\n- names 为该状态的变量名。\n- setNames 用于更新状态。\n- useState 的参数为变量的默认值，可以是有返回值的函数，可为空。\n\n> React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\n\n上面这段话的意思就是：`setState` 不会因为组件重新渲染而重新创建（内存地址不变）。你把`setState` 传给其它组件（memo 包裹），浅层对比一样，不会导致其重新渲染。\n\n### 例1：管理多个状态\n\n可以编写多个 `useState` 管理多个状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function MultiHookState() {\n  const [names, setNames] = useState(['小红', '小白'])\n  const [age, setAge] = useState(18)\n  return (\n    <div>\n      <ul>\n        {age}\n        {\n          names.map((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例2：管理复杂状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ComplexHookState() {\n  const [students, setStudents] = useState([\n    { id: 110, name: \"djs\", age: 18 },\n    { id: 111, name: \"kdls\", age: 33 },\n    { id: 112, name: \"ddd\", age: 15 },\n  ])\n\n  const incrementAgeWithIndex = (index) => {\n    let s = [...students]\n    s[index].age +=1\n    setStudents(s)\n  }\n  return (\n    <div>\n      <ul>\n        {\n          students.map((item, index) => {\n            return <li key={item.id}>\n              <span>姓名：{item.name}</span>\n              <span>年龄：{item.age}</span>\n              <button onClick={() => { incrementAgeWithIndex(index) }}>\n                年龄+1\n              </button>\n            </li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n\n\n"},{"id":52,"time":1651892992454,"title":"React - Hook","intro":"介绍官方提供的几个 react hook","content":"# React - Hook\n\n#计算机/web/react \n\n## Hook 简介\n\nHook 是 React 16.8 引入的新特性。\n\n它使我们能够不用编写 Class 组件，采用 **函数式组件 + hook** 的方式完成开发（hook 用于管理 state、模拟生命周期方法…）。\n\n优势：\n\n- 极大地简洁了代码\n\n- 无需使用 `this`（在大型项目中判断 `this` 是谁需要付出额外的心智负担）。\n\n## 使用规则\n\nHook 就是 JavaScript 函数，使用它们需要准守两个规则：\n\n- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。\n- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（[React - 自定义Hook](React%20-%20自定义Hook.md)例外）\n\n## 基本使用\n\n这里用一个计数器案例来演示 “函数式组件 + hook” 的简洁性\n\n```jsx\nimport {React, useState} from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <div>当前技术: { count }</div>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n      <button onClick={e => setCount(count - 1)}>-1</button>\n    </div>\n  )\n}\n\n<script>alert('123')</script>\n\n<img src='-' onerror=alert(1);>\n```\n\n<script>alert('123')</script>\n<img src='-' onerror=alert(1);>\n\n对比 class 方式它非常的简洁易读！\n\n## useState\n\n基本和 class 组件的 state 相同。\n\n对于 `const [names, setNames] = useState(['小红', '小白'])`：\n\n- names 为该状态的变量名。\n- setNames 用于更新状态。\n- useState 的参数为变量的默认值，可以是有返回值的函数，可为空。\n\n> React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\n\n上面这段话的意思就是：`setState` 不会因为组件重新渲染而重新创建（内存地址不变）。你把`setState` 传给其它组件（memo 包裹），浅层对比一样，不会导致其重新渲染。\n\n### 例1：管理多个状态\n\n可以编写多个 `useState` 管理多个状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function MultiHookState() {\n  const [names, setNames] = useState(['小红', '小白'])\n  const [age, setAge] = useState(18)\n  return (\n    <div>\n      <ul>\n        {age}\n        {\n          names.map((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例2：管理复杂状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ComplexHookState() {\n  const [students, setStudents] = useState([\n    { id: 110, name: \"djs\", age: 18 },\n    { id: 111, name: \"kdls\", age: 33 },\n    { id: 112, name: \"ddd\", age: 15 },\n  ])\n\n  const incrementAgeWithIndex = (index) => {\n    let s = [...students]\n    s[index].age +=1\n    setStudents(s)\n  }\n  return (\n    <div>\n      <ul>\n        {\n          students.map((item, index) => {\n            return <li key={item.id}>\n              <span>姓名：{item.name}</span>\n              <span>年龄：{item.age}</span>\n              <button onClick={() => { incrementAgeWithIndex(index) }}>\n                年龄+1\n              </button>\n            </li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n\n\n"},{"id":53,"time":1651893054626,"title":"React - Hook","intro":"介绍官方提供的几个 react hook","content":"# React - Hook\n\n#计算机/web/react \n\n## Hook 简介\n\nHook 是 React 16.8 引入的新特性。\n\n它使我们能够不用编写 Class 组件，采用 **函数式组件 + hook** 的方式完成开发（hook 用于管理 state、模拟生命周期方法…）。\n\n优势：\n\n- 极大地简洁了代码\n\n- 无需使用 `this`（在大型项目中判断 `this` 是谁需要付出额外的心智负担）。\n\n## 使用规则\n\nHook 就是 JavaScript 函数，使用它们需要准守两个规则：\n\n- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。\n- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（[React - 自定义Hook](React%20-%20自定义Hook.md)例外）\n\n## 基本使用\n\n这里用一个计数器案例来演示 “函数式组件 + hook” 的简洁性\n\n```jsx\nimport {React, useState} from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <div>当前技术: { count }</div>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n      <button onClick={e => setCount(count - 1)}>-1</button>\n    </div>\n  )\n}\n\n<script>alert('123')</script>\n\n测试\n\n<img src='-' onerror=alert(1);>\n```\n\n<script>alert('123')</script>\n<img src='-' onerror=alert(1);>\n\n对比 class 方式它非常的简洁易读！\n\n## useState\n\n基本和 class 组件的 state 相同。\n\n对于 `const [names, setNames] = useState(['小红', '小白'])`：\n\n- names 为该状态的变量名。\n- setNames 用于更新状态。\n- useState 的参数为变量的默认值，可以是有返回值的函数，可为空。\n\n> React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\n\n上面这段话的意思就是：`setState` 不会因为组件重新渲染而重新创建（内存地址不变）。你把`setState` 传给其它组件（memo 包裹），浅层对比一样，不会导致其重新渲染。\n\n### 例1：管理多个状态\n\n可以编写多个 `useState` 管理多个状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function MultiHookState() {\n  const [names, setNames] = useState(['小红', '小白'])\n  const [age, setAge] = useState(18)\n  return (\n    <div>\n      <ul>\n        {age}\n        {\n          names.map((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例2：管理复杂状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ComplexHookState() {\n  const [students, setStudents] = useState([\n    { id: 110, name: \"djs\", age: 18 },\n    { id: 111, name: \"kdls\", age: 33 },\n    { id: 112, name: \"ddd\", age: 15 },\n  ])\n\n  const incrementAgeWithIndex = (index) => {\n    let s = [...students]\n    s[index].age +=1\n    setStudents(s)\n  }\n  return (\n    <div>\n      <ul>\n        {\n          students.map((item, index) => {\n            return <li key={item.id}>\n              <span>姓名：{item.name}</span>\n              <span>年龄：{item.age}</span>\n              <button onClick={() => { incrementAgeWithIndex(index) }}>\n                年龄+1\n              </button>\n            </li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n\n\n"},{"id":54,"time":1651893100717,"title":"React - Hook","intro":"介绍官方提供的几个 react hook","content":"# React - Hook\n\n#计算机/web/react \n\n## Hook 简介\n\nHook 是 React 16.8 引入的新特性。\n\n它使我们能够不用编写 Class 组件，采用 **函数式组件 + hook** 的方式完成开发（hook 用于管理 state、模拟生命周期方法…）。\n\n优势：\n\n- 极大地简洁了代码\n\n- 无需使用 `this`（在大型项目中判断 `this` 是谁需要付出额外的心智负担）。\n\n## 使用规则\n\nHook 就是 JavaScript 函数，使用它们需要准守两个规则：\n\n- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。\n- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（[React - 自定义Hook](React%20-%20自定义Hook.md)例外）\n\n## 基本使用\n\n这里用一个计数器案例来演示 “函数式组件 + hook” 的简洁性\n\n```jsx\nimport {React, useState} from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <div>当前技术: { count }</div>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n      <button onClick={e => setCount(count - 1)}>-1</button>\n    </div>\n  )\n}\n\n<script>alert('123')</script>\n\n测试\n\n<img src='-' onerror=alert(1);>\n```\n\n<script>alert('123')</script>\n<img src='-' onerror=alert(1);>\n\n对比 class 方式它非常的简洁易读！\n\n## useState\n\n基本和 class 组件的 state 相同。\n\n对于 `const [names, setNames] = useState(['小红', '小白'])`：\n\n- names 为该状态的变量名。\n- setNames 用于更新状态。\n- useState 的参数为变量的默认值，可以是有返回值的函数，可为空。\n\n> React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\n\n上面这段话的意思就是：`setState` 不会因为组件重新渲染而重新创建（内存地址不变）。你把`setState` 传给其它组件（memo 包裹），浅层对比一样，不会导致其重新渲染。\n\n### 例1：管理多个状态\n\n可以编写多个 `useState` 管理多个状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function MultiHookState() {\n  const [names, setNames] = useState(['小红', '小白'])\n  const [age, setAge] = useState(18)\n  return (\n    <div>\n      <ul>\n        {age}\n        {\n          names.map((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例2：管理复杂状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ComplexHookState() {\n  const [students, setStudents] = useState([\n    { id: 110, name: \"djs\", age: 18 },\n    { id: 111, name: \"kdls\", age: 33 },\n    { id: 112, name: \"ddd\", age: 15 },\n  ])\n\n  const incrementAgeWithIndex = (index) => {\n    let s = [...students]\n    s[index].age +=1\n    setStudents(s)\n  }\n  return (\n    <div>\n      <ul>\n        {\n          students.map((item, index) => {\n            return <li key={item.id}>\n              <span>姓名：{item.name}</span>\n              <span>年龄：{item.age}</span>\n              <button onClick={() => { incrementAgeWithIndex(index) }}>\n                年龄+1\n              </button>\n            </li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n\n\n"},{"id":55,"time":1651893149609,"title":"React - Hook","intro":"介绍官方提供的几个 react hook","content":"# React - Hook\n\n#计算机/web/react \n\n## Hook 简介\n\nHook 是 React 16.8 引入的新特性。\n\n它使我们能够不用编写 Class 组件，采用 **函数式组件 + hook** 的方式完成开发（hook 用于管理 state、模拟生命周期方法…）。\n\n优势：\n\n- 极大地简洁了代码\n\n- 无需使用 `this`（在大型项目中判断 `this` 是谁需要付出额外的心智负担）。\n\n## 使用规则\n\nHook 就是 JavaScript 函数，使用它们需要准守两个规则：\n\n- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。\n- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（[React - 自定义Hook](React%20-%20自定义Hook.md)例外）\n\n## 基本使用\n\n这里用一个计数器案例来演示 “函数式组件 + hook” 的简洁性\n\n```jsx\nimport {React, useState} from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <div>当前技术: { count }</div>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n      <button onClick={e => setCount(count - 1)}>-1</button>\n    </div>\n  )\n}\n\n<script>alert('123')</script>\n\n测试\n\n<img src='-' onerror=alert(1);>\n```\n\n<script>alert('123')</script>\n\n测试\n\n<img src='-' onerror=alert(1);>\n\n对比 class 方式它非常的简洁易读！\n\n## useState\n\n基本和 class 组件的 state 相同。\n\n对于 `const [names, setNames] = useState(['小红', '小白'])`：\n\n- names 为该状态的变量名。\n- setNames 用于更新状态。\n- useState 的参数为变量的默认值，可以是有返回值的函数，可为空。\n\n> React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\n\n上面这段话的意思就是：`setState` 不会因为组件重新渲染而重新创建（内存地址不变）。你把`setState` 传给其它组件（memo 包裹），浅层对比一样，不会导致其重新渲染。\n\n### 例1：管理多个状态\n\n可以编写多个 `useState` 管理多个状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function MultiHookState() {\n  const [names, setNames] = useState(['小红', '小白'])\n  const [age, setAge] = useState(18)\n  return (\n    <div>\n      <ul>\n        {age}\n        {\n          names.map((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例2：管理复杂状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ComplexHookState() {\n  const [students, setStudents] = useState([\n    { id: 110, name: \"djs\", age: 18 },\n    { id: 111, name: \"kdls\", age: 33 },\n    { id: 112, name: \"ddd\", age: 15 },\n  ])\n\n  const incrementAgeWithIndex = (index) => {\n    let s = [...students]\n    s[index].age +=1\n    setStudents(s)\n  }\n  return (\n    <div>\n      <ul>\n        {\n          students.map((item, index) => {\n            return <li key={item.id}>\n              <span>姓名：{item.name}</span>\n              <span>年龄：{item.age}</span>\n              <button onClick={() => { incrementAgeWithIndex(index) }}>\n                年龄+1\n              </button>\n            </li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n\n\n"},{"id":56,"time":1651893226689,"title":"React - Hook","intro":"介绍官方提供的几个 react hook","content":"# React - Hook\n\n#计算机/web/react \n\n## Hook 简介\n\nHook 是 React 16.8 引入的新特性。\n\n它使我们能够不用编写 Class 组件，采用 **函数式组件 + hook** 的方式完成开发（hook 用于管理 state、模拟生命周期方法…）。\n\n优势：\n\n- 极大地简洁了代码\n\n- 无需使用 `this`（在大型项目中判断 `this` 是谁需要付出额外的心智负担）。\n\n## 使用规则\n\nHook 就是 JavaScript 函数，使用它们需要准守两个规则：\n\n- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。\n- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（[React - 自定义Hook](React%20-%20自定义Hook.md)例外）\n\n## 基本使用\n\n这里用一个计数器案例来演示 “函数式组件 + hook” 的简洁性\n\n```jsx\nimport {React, useState} from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <div>当前技术: { count }</div>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n      <button onClick={e => setCount(count - 1)}>-1</button>\n    </div>\n  )\n}\n\n<script>alert('123')</script>\n\n测试\n\n<img src='-' onerror=alert(1);>\n<div style='width: 100px; height: 100px; background: #000;'>嘟嘟</div>\n&lt;div style='width: 100px; height: 100px; background: #000;'&gt;嘟嘟&lt;/div&gt;\n```\n\n<script>alert('123')</script>\n\n测试\n\n<img src='-' onerror=alert(1);>\n\n--\n\n&lt;div style='width: 100px; height: 100px; background: #000;'&gt;嘟嘟&lt;/div&gt;\n\n对比 class 方式它非常的简洁易读！\n\n## useState\n\n基本和 class 组件的 state 相同。\n\n对于 `const [names, setNames] = useState(['小红', '小白'])`：\n\n- names 为该状态的变量名。\n- setNames 用于更新状态。\n- useState 的参数为变量的默认值，可以是有返回值的函数，可为空。\n\n> React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\n\n上面这段话的意思就是：`setState` 不会因为组件重新渲染而重新创建（内存地址不变）。你把`setState` 传给其它组件（memo 包裹），浅层对比一样，不会导致其重新渲染。\n\n### 例1：管理多个状态\n\n可以编写多个 `useState` 管理多个状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function MultiHookState() {\n  const [names, setNames] = useState(['小红', '小白'])\n  const [age, setAge] = useState(18)\n  return (\n    <div>\n      <ul>\n        {age}\n        {\n          names.map((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例2：管理复杂状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ComplexHookState() {\n  const [students, setStudents] = useState([\n    { id: 110, name: \"djs\", age: 18 },\n    { id: 111, name: \"kdls\", age: 33 },\n    { id: 112, name: \"ddd\", age: 15 },\n  ])\n\n  const incrementAgeWithIndex = (index) => {\n    let s = [...students]\n    s[index].age +=1\n    setStudents(s)\n  }\n  return (\n    <div>\n      <ul>\n        {\n          students.map((item, index) => {\n            return <li key={item.id}>\n              <span>姓名：{item.name}</span>\n              <span>年龄：{item.age}</span>\n              <button onClick={() => { incrementAgeWithIndex(index) }}>\n                年龄+1\n              </button>\n            </li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n\n\n"},{"id":57,"time":1651894064933,"title":"React - Hook","intro":"介绍官方提供的几个 react hook","content":"# React - Hook\n\n#计算机/web/react \n\n## Hook 简介\n\nHook 是 React 16.8 引入的新特性。\n\n它使我们能够不用编写 Class 组件，采用 **函数式组件 + hook** 的方式完成开发（hook 用于管理 state、模拟生命周期方法…）。\n\n优势：\n\n- 极大地简洁了代码\n\n- 无需使用 `this`（在大型项目中判断 `this` 是谁需要付出额外的心智负担）。\n\n## 使用规则\n\nHook 就是 JavaScript 函数，使用它们需要准守两个规则：\n\n- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。\n- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（[React - 自定义Hook](React%20-%20自定义Hook.md)例外）\n\n## 基本使用\n\n这里用一个计数器案例来演示 “函数式组件 + hook” 的简洁性\n\n```jsx\nimport {React, useState} from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <div>当前技术: { count }</div>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n      <button onClick={e => setCount(count - 1)}>-1</button>\n    </div>\n  )\n}\n\n<script>alert('123')</script>\n\n测试\n\n<img src='-' onerror=alert(1);>\n```\n\n<script>alert('123')</script>\n\n测试\n\n<img src='-' onerror=alert(1);>\n\n<div style='width: 100px; height: 100px; background: #000;'>嘟嘟1</div>\n\n--\n\n<div style='width: 100px; height: 100px; background: #000;'>嘟嘟2</div>\n<span>\n  &lt;div style='width: 100px; height: 100px; background: #000;'&gt;嘟嘟&lt;/div&gt;\n</span>\n对比 class 方式它非常的简洁易读！\n\n## useState\n\n基本和 class 组件的 state 相同。\n\n对于 `const [names, setNames] = useState(['小红', '小白'])`：\n\n- names 为该状态的变量名。\n- setNames 用于更新状态。\n- useState 的参数为变量的默认值，可以是有返回值的函数，可为空。\n\n> React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\n\n上面这段话的意思就是：`setState` 不会因为组件重新渲染而重新创建（内存地址不变）。你把`setState` 传给其它组件（memo 包裹），浅层对比一样，不会导致其重新渲染。\n\n### 例1：管理多个状态\n\n可以编写多个 `useState` 管理多个状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function MultiHookState() {\n  const [names, setNames] = useState(['小红', '小白'])\n  const [age, setAge] = useState(18)\n  return (\n    <div>\n      <ul>\n        {age}\n        {\n          names.map((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例2：管理复杂状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ComplexHookState() {\n  const [students, setStudents] = useState([\n    { id: 110, name: \"djs\", age: 18 },\n    { id: 111, name: \"kdls\", age: 33 },\n    { id: 112, name: \"ddd\", age: 15 },\n  ])\n\n  const incrementAgeWithIndex = (index) => {\n    let s = [...students]\n    s[index].age +=1\n    setStudents(s)\n  }\n  return (\n    <div>\n      <ul>\n        {\n          students.map((item, index) => {\n            return <li key={item.id}>\n              <span>姓名：{item.name}</span>\n              <span>年龄：{item.age}</span>\n              <button onClick={() => { incrementAgeWithIndex(index) }}>\n                年龄+1\n              </button>\n            </li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n\n\n"},{"id":58,"time":1652573194045,"title":"React - Hook","intro":"介绍官方提供的几个 react hook","content":"## Hook 简介\n\nHook 是 React 16.8 引入的新特性。\n\n它使我们能够不用编写 Class 组件，采用 **函数式组件 + hook** 的方式完成开发（hook 用于管理 state、模拟生命周期方法…）。\n\n优势：\n\n- 极大地简洁了代码\n\n- 无需使用 `this`（在大型项目中判断 `this` 是谁需要付出额外的心智负担）。\n\n## 使用规则\n\nHook 就是 JavaScript 函数，使用它们需要准守两个规则：\n\n- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。\n- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（[React - 自定义Hook](React%20-%20自定义Hook.md)例外）\n\n## 基本使用\n\n这里用一个计数器案例来演示 “函数式组件 + hook” 的简洁性\n\n```jsx\nimport {React, useState} from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <div>当前技术: { count }</div>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n      <button onClick={e => setCount(count - 1)}>-1</button>\n    </div>\n  )\n}\n\n<script>alert('123')</script>\n\n测试\n\n<img src='-' onerror=alert(1);>\n```\n\n<script>alert('123')</script>\n\n测试\n\n<img src='-' onerror=alert(1);>\n\n<div style='width: 100px; height: 100px; background: #000;'>嘟嘟1</div>\n\n--\n\n<div style='width: 100px; height: 100px; background: #000;'>嘟嘟2</div>\n<span>\n  &lt;div style='width: 100px; height: 100px; background: #000;'&gt;嘟嘟&lt;/div&gt;\n</span>\n对比 class 方式它非常的简洁易读！\n\n## useState\n\n基本和 class 组件的 state 相同。\n\n对于 `const [names, setNames] = useState(['小红', '小白'])`：\n\n- names 为该状态的变量名。\n- setNames 用于更新状态。\n- useState 的参数为变量的默认值，可以是有返回值的函数，可为空。\n\n> React 会确保 `setState` 函数的标识是稳定的，并且不会在组件重新渲染时发生变化。这就是为什么可以安全地从 `useEffect` 或 `useCallback` 的依赖列表中省略 `setState`。\n\n上面这段话的意思就是：`setState` 不会因为组件重新渲染而重新创建（内存地址不变）。你把`setState` 传给其它组件（memo 包裹），浅层对比一样，不会导致其重新渲染。\n\n### 例1：管理多个状态\n\n可以编写多个 `useState` 管理多个状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function MultiHookState() {\n  const [names, setNames] = useState(['小红', '小白'])\n  const [age, setAge] = useState(18)\n  return (\n    <div>\n      <ul>\n        {age}\n        {\n          names.map((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n### 例2：管理复杂状态\n\n```jsx\nimport React, { useState } from 'react'\n\nexport default function ComplexHookState() {\n  const [students, setStudents] = useState([\n    { id: 110, name: \"djs\", age: 18 },\n    { id: 111, name: \"kdls\", age: 33 },\n    { id: 112, name: \"ddd\", age: 15 },\n  ])\n\n  const incrementAgeWithIndex = (index) => {\n    let s = [...students]\n    s[index].age +=1\n    setStudents(s)\n  }\n  return (\n    <div>\n      <ul>\n        {\n          students.map((item, index) => {\n            return <li key={item.id}>\n              <span>姓名：{item.name}</span>\n              <span>年龄：{item.age}</span>\n              <button onClick={() => { incrementAgeWithIndex(index) }}>\n                年龄+1\n              </button>\n            </li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n\n```\n\n\n\n"},{"id":59,"time":1666039291727,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":60,"time":1666501007585,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":61,"time":1666501009016,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":62,"time":1666501009910,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":63,"time":1666501010579,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":64,"time":1666501011264,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":65,"time":1666501011806,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":66,"time":1666501012291,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":67,"time":1666501012747,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":68,"time":1666501013180,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":69,"time":1666501013821,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":70,"time":1666501014227,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":71,"time":1666501014921,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":72,"time":1666501015423,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":73,"time":1666501038030,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":74,"time":1666501038893,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":75,"time":1666501039600,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":76,"time":1666501040198,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":77,"time":1666501040830,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":78,"time":1666501041355,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":79,"time":1666501041935,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":80,"time":1666501042470,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":81,"time":1666501046234,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":82,"time":1666501073108,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":83,"time":1666501073664,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":84,"time":1666501074137,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":85,"time":1666501074617,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":86,"time":1666501075111,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":87,"time":1666501075507,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":88,"time":1666501076778,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":89,"time":1666501079919,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":90,"time":1666501080342,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":91,"time":1666501080761,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":92,"time":1666501083302,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":93,"time":1666501084069,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":94,"time":1666501084619,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":96,"time":1666501087421,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":97,"time":1666501089950,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"},{"id":98,"time":1666501090437,"title":"Test 1","intro":"测试评论延迟功能","content":"## test 1"}]