[{"id":1,"time":1672441448575,"title":"百分比布局","intro":"百分比布局","content":"# 百分比布局\n\n\n```html\n<section>\n    <div></div>\n    <div></div>\n</section>\n```\n\n```css\n* {\n    margin: 0;\n    padding: 0;\n}\n\nsection {\n    width: 100%;\n    /* 一般会设置一个范围，避免变形 */\n    max-width: 980px;\n    min-width: 320px;\n    margin: 0 auto;\n}\n\nsection div {\n    float: left;\n    width: 50%;\n    height: 400px;\n}\n\nsection div:nth-child(1) {\n    background-color: pink;\n}\n\nsection div:nth-child(2) {\n    background-color: purple;\n}\n```\n","views":4},{"id":2,"time":1672441497206,"title":"操作系统的一些概念","intro":"操作系统的一些概念","content":"# 操作系统的一些概念\n\n## 内存管理\n\n很早前 DOS 时代，内存是由程序自己控制。\n\nwindows 时代，由操作系统统一管理。\n\n以32为操作系统为例，最多能够管理的内存为4G。\n\n每个程序看到的都是4G的虚拟内存，实际上由操作系统来映射真实的内存地址。这样做不需要关心真实的内存地址，降低心智负担。\n\n **虚拟存储器**\n\n1. 现代CPU都有多个核心，其中 ALU（计算单元）从 CPU 寄存器拿数据用于计算。CPU 寄存器存取数据非常快，但容量极小，也最贵。\n2. 每个核心有自己的缓存：L1 速度比寄存器慢一些、大很多、便宜一些；L2 较 L1 更慢一些、大一些、便宜一些；整个CPU还有一个 L3 缓存，较 L2 更慢、更大、更便宜；\n3. 内存：就是内存条，较 L3 缓存更慢、更大、更便宜。\n4. 硬盘：持久化的存数据，较内存条更慢、更大、更便宜。速度上：SSD > 机械。\n5. 再慢点的就是网络传输\n\n搞这么多级就是为了在速度与成本间做取舍。\n\n存储器山：寄存器 > L1 > L2 > L3 > 内存 > 硬盘。\n\nCPU在执行时就是逐级往上加载数据。\n\n**虚拟存储器，统一的内存模型**\n\n以一个4G内存的电脑为例，每一个程序看到的都是4G的虚拟内存。\n假设：\nA程序使用了1G。\nB程序使用了1G。\n\n> **页表**：A 和 B 看到的都是4G的虚拟内存，虚拟内存地址看起来一样。但数据实际存储的物理内存地址肯定是不一样的。这个映射关系是由一个称为“页表”的东西来记录的。操作系统中每一个进程都会有一个“页表”，用来记录映射关系。\n>\n> 此时C程序马上需要3G内存来执行。\n> 这个时候就需要把A或B卸载，写入硬盘缓存里保存起来。腾出了1G空间，刚好够C程序运行，再加载C程序。（这个过程是由操作系统来执行的。）\n>\n> 假设我马上又需要执行A程序，这个时候就又有一个IO过程，会严重拖慢电脑。\n## 驱动\n\n对硬件的抽象层，向外暴露一个统一的接口。\n\n比如 usb 键盘、蓝牙键盘，通过驱动抽象统一接口，使你无需关心兼容问题。\n\n## 文件系统\n\n可以理解为一个很大的数组。\n\n[meta元信息 文件位置 文件大小] 这样就可以快速的找到文件。\n\n平时使用的快速（高级）格式化，实际上就是把元信息清除。如果实际文件没有被覆盖的话，可以恢复。\n\n常规（低级）格式化就不行了。\n\n## 进程、线程\n\n> windows可以通过任务管理器直接查看进程。\n\n进程是资源分配的最小单位，可以理解为一个容器，每个进程都有自己单独的页表（映射内存地址）。因为共享页表，进程内的多个线程可以共享数据。\n\n线程是CPU运算调度的最小单位，一个单一顺序的控制流，用于执行某个任务。一个进程中可以有n个线程，线程共享数据（页表）。\n\n### 进程是如何实现的？\n\n进程的实现其实和你的cpu是单核还是多核没有关系，它是把一段时间切分的非常小，称为“时间片”，每个时间片只执行某个程序的很小一部分，因为时间非常的短，人类无法感知，使你能够“同时”执行多个操作，多个程序也能同时的推进。\n\n### 多线程\n\n在一个进程中，你可能需要执行多个操作，这个时候就需要开多个线程。\n线程间可以共享进程内的数据（共享页表）。\n\n### 进程和线程的区别\n\n进程间通信比较麻烦，如：pipe（管道）、file、socket，都需要中转，所以很慢。\n\n线程间通信很简单，因为它们共享同一张页表，数据都是可见的，所以它们可以互相通信。\n\n而进程间都有自己的页表，它们都认为自己独占所有内存，它们互相看不见，所以需要通过中间层来实现通信。\n\n### 多线程同步问题\n\n多个线程的调度是由操作系统决定的，程序无法决定。因此，某个线程可能在任何指令处被操作系统暂停，然后在某个时刻恢复。\n\n这就会出现一个问题：当多个线程读写共享变量时，可能造成数据不一致。\n\n**例子：A、B两个线程，对 count 进行加一操作。**\n\n- 一个文件存了个变量 count = 0\n- A线程读取并count加一，此时count为1。这时，操作系统将本线程暂停，还没来得及保存到文件，就切换到线程B。\n- B线程也读取并count加一，此时count还是1，保存到文件。\n- 切换到A线程继续执行操作：保存。这就出现问题了，我们期望count是2，却被覆盖保存，count还是1。\n\n造成上面问题的核心就是，A、B线程可被拆分，它们不是“原子操作”。\n\n#### 解决方案：加锁\n\n常见的有：互斥锁、条件变量、读写锁、自旋锁、信号量。\n\n这里只介绍互斥锁：A线程访问变量，加锁，在A线程没有结束操作并解锁前，其他线程都需要等待。这样就保证了操作的原子性。\n\n#### 新的问题：死锁\n\n**什么是死锁？**\n\n现在有两个资源1和资源2，我们有A、B两个线程去访问。\n\n- A要先拿1再拿2才进行操作，拿不全就等待。\n- B要先拿2再拿1其他同上。\n\n假设它们两个线程抢的都非常快，A拿了1、加锁，B拿了2、加锁。\n\n因为它们要拿全资源才进行操作，所以它们都会等待对方手里的资源，两个线程就会无限的等待，陷入“死锁”。\n\n**解决方案**\n\n1. 调整顺序，A、B两个线程都先拿1再拿2\n2. 两个线程都必须拿到全部资源才操作（该例中1和2都拿到），否者扔掉。\n\n## 并发、并行\n\n并发：一段时间内，多个任务流可以交替执行。\n\n并行：真正（物理）意义上的同时执行多个任务，由多个 CPU 核心同时执行。\n\n**举个例子：你在吃面，突然来了电话。**\n\n- 并发：你停止吃面，接完了电话再继续吃面。\n- 并行：你一边吃面，一边接电话。\n\n## 同步异步 阻塞非阻塞\n\n- 同步：事件的发生与否，需要你自己去检查。\n\n- 异步：事件的发生与否，是由别人通知给你的。\n\n比如 AJAX 可以同步也可以异步。\n\n你同步请求，就会一直等待服务器返回数据，不继续执行代码。\n\n而异步请求，会把回调函数放到一边，继续执行其他任务，等返回数据了再通知你继续执行。\n\n- 阻塞：上面例子的 AJAX 同步请求就是阻塞。\n- 非阻塞：AJAX 异步请求就是非阻塞。\n\n## 编译 解释 JIT\n\n编译：比如C语言，编译到机器码（机器指令码）才可执行。编译会很慢，而且不同的平台需要编译不同版本，因为它们的指令集不同。\n\n解释：比如使用C语言针对不同平台（windows、Mac、Linux…）开发一个虚拟机，它的指令集是固定的。这时比如你有一个Python语言，只需要逐条的转换成这个虚拟机的指令即可。\n\nJIT（just-in-time compilation）即时编译：JavaScript就是JIT的语言，只编译、执行需要的代码，还会把运行次数很多的代码编译成机器码，省略了中间转换步骤以提高效率。更多操作可以看这篇译文：[JavaScript 编译 - JIT (just-in-time) compiler 是怎么工作的](https://zhuanlan.zhihu.com/p/99395691)\n\n## 动态语言与静态语言\n\n动态语言：\n\n```js\nvar a = ''\n//可转换类型\na = []\na = {}\n```\n\n静态语言：`a = ''` 以后只能是 String 类型，不能再转换为其他类型了。\n\n## 强类型与弱类型\n\n强类型：`1 + '1'` 报错。\n\n弱类型：如 JS `1 + '1'` 结果是 `'11'`。\n\n## 有GC 与 无GC\n\nGC（Garbage Collection）：垃圾回收。\n\n有GC的语言：JavaScript、Python、Golang、java等\n\n无GC的语言：C、C++\n\n无GC的语言，比如你 `new ` 了一个东西，你需要记得 `delete` 否者就一直占着内存。\n\n有GC的语言，会自动帮你回收不用的东西，有效降低心智负担。\n\n## 常见的GC算法\n\n### 引用计数法\n\n> 这个算法非常初级，早期浏览器就是采用的这种方法。\n\n对于一个对象a，如果没有其他对象引用它，就垃圾回收。\n\n**以JS代码为例**\n\n```js\nvar a = {\n  name: 'monkey'\n}\n\nvar b = a // 此时有两个变量引用了该对象\n\na = 1 // 只有一个(b)了\nb = null // 0个引用，上面的对象被垃圾回收\n```\n\n**局限：循环引用**\n\n引用计数法无法解决循环引用无法回收的问题，下面以JS为例：\n\n```js\nvar f = function() {\n  var o1 = {}\n  var o2 = {}\n  o1.a = o2\n  o2.b = o1\n}\n\nf()\n```\n\n上面例子两个对象互相引用，构成一个循序，它们两个对象都持有一个引用，导致无法被垃圾回收。（这种现象叫做内存泄漏。）\n\n### 标记-清除算法\n\n> 关于浏览器：从2012年起，所有的现代浏览器都是用了该算法。所以不用担心上一节的循环引用问题了。\n\n该算法把GC分为了两个阶段：\n\n- 标记阶段：把所有的活动对象做上标记。\n- 清除阶段：把没有标记的对象销毁。\n\n**具体实现**\n\n标记：\n\n- 这个算法假定设置一个根（root）对象（JS中就是 window）。\n\n- 垃圾回收器会定期从根开始，找所有从根开始引用的对象，然后找这些对象的引用对象，这样逐层遍历下去，把遍历到的对象打上标记。\n\n清理：\n\n- 整个再遍历一遍，没有被标记的对象被垃圾清理。\n\n## 协程\n\n> 朋友聚会去饭馆，点好菜可以有两种吃法，第一种，等菜上完大家动筷子，第二种，上一道吃一道。如果按第一种吃法，吃饭的程序要等待做饭的程序（饭馆）全部执行完；按第二种吃法，吃饭的程序和做饭的程序就完成了解耦，做饭的做他的，快或者慢，只要上，吃饭的就吃，不依赖一个最终状态。这两种方法不改变菜的品种质量。但流程效益却不同，如果上一道吃一道，吃完的盘子就可以清掉，如果按第一种吃法，上到中间发现桌子不够大，盘子要叠罗汉。而且第一种吃法，喜欢吃某个菜的朋友可以先吃到，不必死等流口水。如果点三道菜，两种吃法或许没太大差异。但是你想像一下，假设点了3000道菜，两种吃法的效率当下立现，如果按第一种吃法，大家都饿死了，即使做好了，桌子（内存）也放不下。\n>\n> 我上面说解耦，并不完全准确，准确得说，**吃饭的程序不再依赖于整桌菜，而只依赖于下一道菜**，而依赖于前者往往空间和时间效益都低，而依赖于后者较高。\n>\n> 作者：dboy\n> 链接：https://www.zhihu.com/question/55810122/answer/146654766\n> 来源：知乎\n\n协程是在单核CPU场景中发展出来的概念，通过**挂起**、**恢复**接口，把一个线程切分成了多个任务段（控制权是由程序决定），以实现交叉执行多个任务的并发功能。\n\n协程相比于多线程的优势就是，线程切换需要消耗资源，比如你有10000个用户请求，你开10000个线程资源消耗是可怕的，而协程是对线程的时间片做分配，有效降低开销。\n\n实际开发中，协程适合IO密集型的任务。协程中不要同步的调用阻塞IO的方法（如：文件读取），协程要配合异步IO才能发挥最大威力，通过挂起、恢复操作以最大程度利用CPU。\n","views":21},{"id":3,"time":1672441729396,"title":"单页应用，路由history模式，build后刷新404问题","intro":"单页应用，路由history模式，build后刷新404问题","content":"# 单页应用，路由history模式，build后刷新404问题\n\n\n## 问题\n\n在单页应用开发中，本地调试没问题，但是项目上线后，比如在 `/article/58` 路径，刷新就会返回 404，正常点击进入没有问题，这就是因为该 url 没有对于的 index 文件造成的。\n\n如果采用 hash 模式路由，就不会有问题，因为一直都是那个 index 文件。\n\n但采用 history 模式，就需要做一些处理了。\n\n## 解决\n\nnginx配置\n\n> 以 ubuntu 为例，编辑 `/etc/nginx/sites-available/default`\n\n```shell\nserver {\n\tlocation / {\n    # 把所有 404 重定向到 index 文件就好了。\n\t\ttry_files $uri $uri/ /index.html;\n}\n```\n\n如果真的 404 了呢？\n\n> 在前端路由处理\n\n```js\nconst router = [\n\t{\n    path: '/',\n    element: <HomePage /> \n  },\n  // ...省略更多\n  {\n    path: '*',\n    element: <Error404 />\n  }\n]\n\nexport default router\n```\n\n","views":4},{"id":4,"time":1672444177388,"title":"IE盒模型和标准盒模型","intro":"IE盒模型和标准盒模型","content":"# IE盒模型和标准盒模型\n\n#计算机/web/css \n\n## IE模型\n\nIE盒模型在设置 width、height 时，会包含`padding`、`border`。\n\n```css\n.box {\n    box-sizing: border-box; /*使用IE盒模型*/\n}\n```\n\n**这样设置了宽高后，就不用担心被 padding、border 撑开了。**\n\n## 标准盒模型\n\n标准盒模型在设置了宽高后，有可能被子元素撑开，导致所占空间变大\n\n```css\n.box {\n    box-sizing: content-box; /*默认的*/\n}\n```\n","views":8},{"id":5,"time":1672528881882,"title":"axios - 基于promise的HTTP库123","intro":"Axios 是一个基于 promise 的 HTTP 库，可以用在 浏览器 和 Node.js 中。","content":"# axios - 基于promise的HTTP库\n\nAxios 是一个基于 promise 的 HTTP 库，可以用在 浏览器 和 Node.js 中。\n\n> 本例使用测试服务器：http://httpbin.org\n\n## 功能\n\n- 从浏览器中创建 [XMLHttpRequests](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)\n- 从 node.js 创建 [http](http://nodejs.org/api/http.html) 请求\n- 支持 [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) API\n- 拦截请求和响应\n- 转换请求数据和响应数据\n- 取消请求\n- 自动转换 JSON 数据\n- 客户端支持防御 [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)\n\n## 兼容性\n\nIE11+ [详情](https://github.com/axios/axios#browser-support)\n\n## 安装\n\n```shell\nnpm i axios\nyarn add axios\n```\n\n## axios(config)\n\n```js\naxios({\n      url: 'http://httpbin.org/image/jpeg',\n      method: 'get',\n      responseType: 'blob'\n    })\n      .then((res) => {\n        let url = window.URL.createObjectURL(res.data)\n        this.setState({\n          url: url\n        })\n      })\n      .catch((err) => {\n        console.log(err)\n      })\n```\n\n## 别名\n\n为方便起见，为所有支持的请求方法提供了别名\n\n`axios.request(config)`：执行`axios(confing)` 本质就是在执行该方法。\n\n`axios.get(url[, config])`\n\n`axios.post(url[, data[, config]])`\n\n`axios.put(url[, data[, config]])`\n\n`axios.patch(url[, data[, config]])`\n\n`axios.delete(url[, config])`\n\n`axios.head(url[, config])`：获取 http 头信息。应用场景：检查某个文件是否存在。\n\n`axios.options(url[, config])`：发送预检请求，获取服务器支持的请求方法、服务器性能。执行副作用操作时，浏览器自动发送。[参考1](https://cloud.tencent.com/developer/article/1046663)、[参考2](https://juejin.cn/post/6844903821634699277#heading-8)\n\n==TODO:http请求方法弄懂==\n\n## 并发\n\n两个助手函数：\n\n- `axios.all(iterable)`\n\n- `axios.spread(callback)`\n\n`axios.all(iterable)` 本质上使用的是 `Promise.all()` ，所以所有输入的请求都成功，才会调用成功回调。\n\n`axios.spread(callback)` 可以使用**数组解构**替代。\n\n```js\nlet requestOne = axios.get('http://httpbin.org/get')\nlet requestTwo = axios.post('http://httpbin.org/post', { name: '猴几' })\n\n// 该方法本质使用 Promise.all()\naxios.all([requestOne, requestTwo])\n  // 使用spread助手函数\n  // .then(axios.spread((res1, res2) => {\n  //   console.log(res1, res2);\n  // }))\n\n  // or\n\n  // 使用数组解构\n  .then(([res1, res2]) => {\n    // 两个请求都成功才会调用\n    console.log(res1, res2)\n  })\n  .catch((err) => {\n    console.log(err)\n  })\n```\n\n## 创建实例\n\n一种应用场景，在一个项目中需要向两个或多个不同的服务器发送请求，这个是在就可以新建多个 axios 实例，分别配置不同的默认配置。\n\n```js\nconst instance1 = axios.create({\n  baseURL: 'http://httpbin.org',\n  timeout: 1000,\n})\n\ninstance1.get('/get')\n  .then(data => {\n    console.log(data)\n  })\n  .catch(err => {\n    console.log(err)\n  })\n\nconst instance2 = axios.create({\n  baseURL: 'http://其他域名.com',\n  // ...\n})\n// ...其他操作\n```\n\n> 实例同样有别名，见“别名”小节。\n\n## 请求配置\n\n这些是创建请求时可以用的配置选项。只有 `url` 是必需的。如果没有指定 `method`，请求将默认使用 `get` 方法。\n\n```js\n{\n  // `url` 是用于请求的服务器 URL\n  url: '/user',\n\n  // `method` 是创建请求时使用的方法\n  method: 'get', // default\n\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` 允许在向服务器发送前，修改请求数据\n  // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法\n  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n  transformRequest: [function (data, headers) {\n    // 对 data 进行任意转换处理\n    return data;\n  }],\n\n  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) {\n    // 对 data 进行任意转换处理\n    return data;\n  }],\n\n  // `headers` 是即将被发送的自定义请求头\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  // `params` 是即将与请求一起发送的 URL 参数\n  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` 是一个负责 `params` 序列化的函数\n  // (qs是一个增强的查询字符串库: https://www.npmjs.com/package/qs)\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: 'brackets'})\n  },\n\n  // `data` 是作为请求主体被发送的数据\n  // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'\n  // 在没有设置 `transformRequest` 时，必须是以下类型之一：\n  // - string, plain object, ArrayBuffer, \n  //   ArrayBufferView, URLSearchParams\n  // - 浏览器专属：FormData, File, Blob\n  // - Node 专属： Stream\n  data: {\n    firstName: 'Fred'\n  },\n\n  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n  timeout: 1000,\n\n  // `withCredentials` 表示跨域请求时是否需要使用凭证\n  withCredentials: false, // default\n\n  // `adapter` 允许自定义处理请求，以使测试更轻松\n  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据\n  // 这将设置一个 `Authorization` 头，\n  // 覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responseType` 表示服务器响应的数据类型，\n  // 可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n  responseType: 'json', // default\n\n  // `responseEncoding` indicates encoding to use for decoding responses\n  // Note: Ignored for `responseType` of 'stream' or client-side requests\n  responseEncoding: 'utf8', // default\n\n   // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value\n  xsrfHeaderName: 'X-XSRF-TOKEN', // default\n\n   // `onUploadProgress` 允许为上传处理进度事件\n  onUploadProgress: function (progressEvent) {\n    // Do whatever you want with the native progress event\n  },\n\n  // `onDownloadProgress` 允许为下载处理进度事件\n  onDownloadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n   // `maxContentLength` 定义允许的响应内容的最大尺寸\n  maxContentLength: 2000,\n\n  // `validateStatus` 定义对于给定的 HTTP 响应状态码\n  //  是 resolve 或 reject promise 。\n  //  如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，\n  //  promise 将被 resolve; 否则，promise 将被 reject\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目\n  // 如果设置为0，将不会 follow 任何重定向\n  maxRedirects: 5, // default\n\n  // `socketPath` defines a UNIX Socket to be used in node.js.\n  // e.g. '/var/run/docker.sock' to send requests to the docker daemon.\n  // Only either `socketPath` or `proxy` can be specified.\n  // If both are specified, `socketPath` is used.\n  socketPath: null, // default\n\n  // `httpAgent` 和 `httpsAgent`，\n  // 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。\n  // 允许像这样配置选项：\n  // `keepAlive` 默认没有启用\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // 'proxy' 定义代理服务器的主机名称和端口\n  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据\n  // 这将会设置一个 `Proxy-Authorization` 头，\n  // 覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。\n  proxy: {\n    host: '127.0.0.1',\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `cancelToken` 指定用于取消请求的 cancel token\n  // （查看后面的“取消请求”一节了解更多）\n  cancelToken: new CancelToken(function (cancel) {\n  })\n}\n```\n\n## 响应结构\n\n某个请求的响应包含以下信息\n\n```js\n{\n  // `data` 由服务器提供的响应\n  data: {},\n\n  // `status` 来自服务器响应的 HTTP 状态码\n  status: 200,\n\n  // `statusText` 来自服务器响应的 HTTP 状态信息\n  statusText: 'OK',\n\n  // `headers` 服务器响应的头\n  headers: {},\n\n  // `config` 是为请求提供的配置信息\n  config: {},\n  // `request`\n  // 在浏览器中它是 XMLHttpRequest 的实例\n  // It is the last ClientRequest instance in node.js (in redirects)\n  request: {}\n}\n```\n\n## 配置默认值\n\n配置全局默认值\n\n```js\n// 配置全局默认配置\naxios.defaults.baseURL = 'http://httpbin.org';\naxios.defaults.headers.common['token'] = 'sdjlfjsld';\n// ...更多\n```\n\n配置实例默认值\n\n```js\nconst instance = axios.create({\n  baseURL: 'http://httpbin.org',\n  // ...更多\n});\n\n//如果需要，还可以在创建实例后修改默认值\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n## 配置优先级\n\n请求的 `config` > 实例的 `config` > 全局默认的  `config` 。\n\n简单点说就是，后者覆盖前者。\n\n## 拦截器\n\n在请求或响应被 `then` 或 `catch` 处理前拦截它们。\n\n**请求拦截器**\n\n```js\naxios.interceptors.request.use(config => {\n  console.log('在请求发送前，干一些事');\n  // 比如：\n  // 1.发送网络请求时，在页面中添加一个loading组件作为动画；\n  // 2.某些网络请求要求用户必须登录，可以在请求中判断是否携带了token，\n  //   没有携带token直接跳转到login页面；\n  // 3.对某些请求参数进行序列化。比如使用 qs 库\n\n  // 必须把配置return出去\n  return config;\n}, (err) => {\n  console.log('对请求错误进行一些操作');\n  return Promise.reject(err)\n})\n\n```\n\n**响应拦截器**\n\n```js\naxios.interceptors.response.use(response => {\n  console.log('对响应数据进行一些操作')\n  return response.data;\n}, (err) => {\n  console.log('对响应错误进行一些操作');\n  return Promise.reject(err)\n})\n```\n\n## 取消请求\n\n### 方式一：使用 `CancelToken.source` 工厂函数\n\n```js\nconst CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\n// 该请求延迟10s。\naxios.get('/delay/10', {\n  cancelToken: source.token\n})\n  .then((data) => {\n  \tconsole.log('延迟响应返回数据', data);\n\t})\n  .catch((err) => {\n    if(axios.isCancel(err)) {\n      console.log('请求被取消：', err.message);\n    } else {\n      console.log('其他错误');\n    }\n\t})\n\n// 设置一个3s后取消请求\nsetTimeout(() => {\n  // 取消请求。参数message可选。\n  source.cancel('服务器延迟设置的10s，这里在3s后取消了请求。');\n}, 3000)\n\n```\n\n### 方式二：构造函数\n\n```js\nconst CancelToken = axios.CancelToken;\nlet cancel;\n\naxios.get('/delay/10', {\n  cancelToken: new CancelToken(function executor(c) {\n    // executor 函数接收一个 cancel 函数作为参数\n    cancel = c;\n  })\n});\n\n// cancel the request\ncancel();\n```\n\n### 应用场景\n\n- 单页应用切换路由时，取消正在放松的请求。提高性能、避免BUG\n- 上传、下载文件中途取消。\n\n### 取消请求的源码实现\n\n[CancelToken 源码地址](https://github.com/axios/axios/blob/9a78465a9268dcd360d7663de686709a68560d3d/lib/cancel/CancelToken.js)\n\n```js\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n   \t// 这个属性被调用就会把 promise 设置为 resolve\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    // 调用该方法相当于调用 resolve()\n    // promise 状态设置为 resolve\n    resolvePromise(token.reason);\n  });\n}\n\n// 这个就是工厂函数（上面的方式一）\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n```\n\n注意看上面代码，调用 `CancelToken.source.cancel` 就相当于调用了：\n\n```js\nfunction cancel(message) {\n  if (token.reason) {\n    // Cancellation has already been requested\n    return;\n  }\n\n  token.reason = new Cancel(message);\n \t// 该方法把 promise 设置为了 resolve 状态，\n  // 导致下方源码成功回调被调用，从而取消请求\n  resolvePromise(token.reason);\n}\n```\n\n[xhr.js 源码地址](https://github.com/axios/axios/blob/b7e954eba3911874575ed241ec2ec38ff8af21bb/lib/adapters/xhr.js)\n\n```js\nvar request = new XMLHttpRequest();\n\nif (config.cancelToken) {\n// 处理取消请求。\nconfig.cancelToken.promise\n  .then(function onCanceled(cancel) {\n    // CancelToken 实例的 promise 被设置为 resolve ，这个回调就会执行。\n    if (!request) {\n      return;\n    }\n    //取消请求\n    request.abort();\n    reject(cancel);\n    // Clean up request\n    request = null;\n  });\n}\n```\n\n## axios 二次封装\n\n为什么要二次封装？\n\n> 假如项目中有100处直接使用了 axios，有一天 axios 出现重大 BUG / 不维护了 / 更好的替代品，我们需要对其进行替换，这是一个很大的工作量。\n>\n> 但如果我们对其进行了二次封装，在项目中使用我们自己封装的一套 API。在需要替换时，就只需要对我们封装的代码进行修改，并保证导出的 API 格式不变即可。\n\n新建 `src/service` 文件夹。\n\n新建 `src/service/config.js`\n\n```js\n// 假如开发/生产环境使用两个不同的服务器\nconst devBaseURL = 'http://httpbin.org'\nconst proBaseURL = 'http://生产环境.com'\n\n// 根据开发/生产环境自动切换服务器。\nexport const baseURL = process.env.NODE_ENV === 'development' ? devBaseURL: proBaseURL;\nexport const TIMEOUT = 5000;\n// Token...等等更多配置信息\n```\n\n新建 `src/service/request.js`\n\n```js\nimport axios from \"axios\";\n\nimport { baseURL, TIMEOUT } from \"./config\";\n\nconst request = axios.create({\n  baseURL: baseURL,\n  timeout: TIMEOUT,\n})\n\n// - 可以在这里添加拦截器、取消请求等等API\n\n// - 可以封装一套自己的方法，分别导出。 get post put delete...\n// const get = () => {...}\n// export {get, post 。。。}\n\n// 这里为了演示方便直接导出了 axios 的实例对象。\nexport default request\n```\n\n使用\n\n```js\nimport request from './service/request'\nrequest.get('/get').then((res) => {\n  console.log('二次封装：', res.data)\n})\n```\n\n\n\n","views":1079},{"id":6,"time":1672540312960,"title":"npm&git设置代理","intro":"npm&git设置代理","content":"## npm设置代理\n\n#计算机/综合知识 \n\n```shell\nnpm config set proxy http://127.0.0.1:10801\nnpm config set https-proxy http://127.0.0.1:10801\n```\n\n## git设置代理\n\n用户目录下有一个`.gitconfig`文件，配置：\n\n```shell\n[http]\n\tproxy = http://127.0.0.1:10801\n[https]\n\tproxy = https://127.0.0.1:10801\n","views":4}]