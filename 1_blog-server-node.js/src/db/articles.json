[{"id":2,"time":1679074125753,"title":"JavaScript执行上下文","intro":"通过执行上下文理解变量提升、作用域、作用域链、闭包、this。","content":"# JS - 执行上下文\n\n## 什么是执行上下文？\n\n一段代码执行时所需要的所有信息的集合，就是执行上下文。\n\n## 从编译到执行\n\nJavaScript 引擎在真正执行我们写的代码前会先进行编译操作（所以 JavaScript 被称为即时编译语言更准确）。\n\n步骤：编译 -> 创建执行上下文，在准备完毕后 -> 一行行的执行可执行代码。\n\n## 执行上下文的组成\n\n执行上下文由以下几个部分组成：\n\n- 变量环境（Variable environment）\n- 词法环境（Lexical environment）\n- 外部引用（outer）\n- this\n\n*记住它们，下面开始逐一讨论*\n\n## 变量环境（Variable environment）\n\n*本节仅讨论变量环境*\n\n### 变量与变量环境\n\n以一个例子开始：\n\n```js\nvar apple = 10\nconsole.log(apple)\n```\n\n- 这段代码被执行，首先进行编译：执行上下文被创建，变量 `apple` 被赋值为 `undefined`，并储存到变量环境中。\n- 编译结束，开始执行。\n- 执行到第一行，变量 `apple` 被赋值为 `10`，并更新到变量环境中。\n- 执行到第二行，JS引擎发现需要使用到变量 `apple`，到变量环境中找到，然后在控制台出数字 `10`。\n- 程序执行结束，该执行上下文被弹出。\n\n\n\n从这个例子中，我们可以看出如下几个关键点：\n\n*   一个变量赋值语句实际是上被分成两步\n*   编译阶段主要关心变量的声明\n*   执行阶段执行变量的赋值和剩下的代码\n\n### 变量提升\n\n有了上面例子的铺垫，解释变量提升就很容易了。还是以例子开始：\n\n```js\nconsole.log(apple)\nvar apple = 10\n```\n\n> 执行结果，控制台打印 undefined。\n\n下面以执行上下文的角度来解释：\n\n- 编译阶段：第一行代码被跳过，因为它不涉及变量声明。第二行发现变量声明，`apple` 被赋值为 `undefined` 并储存在变量环境中。\n- 编译阶段结束，开始执行。\n- 执行到第一行，在变量环境中找到 `apple` ，此时它为 `undefined`，所以在控制台打印 `undefined`。\n- 执行到第二行，`apple` 被赋值为10，并更新到变量环境中。\n- 程序执行结束，该执行上下文被弹出。\n\n所以并没有所谓的变量提升，只不过是在编译阶段变量被声明并赋值为了 `undefined` 罢了。\n\n### 函数的提升\n\n函数的提升有所不同，因为要考虑到两种函数声明方式：\n\n（1）函数表达式：\n\n```js\nsayHello()\n\nvar sayHello = function() {\n  console.log('hello')\n}\n```\n\n上面代码控制台会打印出：‘sayHello is not a function’，根据上面小节可知，执行该函数时 `sayhello = undefined` ，自然不是函数。\n\n（2）函数声明：\n\n```js\nsayHi()\n\nfunction sayHi() {\n  console.log('hi')\n}\n```\n\n上面代码正常打印：’hi‘。因为它是一个函数的声明，在编译阶段 `sayHi` 函数体会被保存在一个叫做 HEAP（堆）的地方，而 `sayHi` 这个变量仅仅保存指向这个函数体的内存地址。在执行阶段，JS引擎会根据内存地址，在堆中找到并执行函数，正常打印 ’hi‘。\n\n### 两个例子进一步理解编译技巧\n\n例1，函数命名冲突：\n\n```js\nsayHi()\n\nfunction sayHi() {\n  console.log('hi - 1')\n}\n\nvar sayHi = function() {\n  console.log('hi - 2')\n}\n```\n\n上面例子会打印出 ‘hi - 1’。这是因为函数的声明优先级更高。我们在实际开发中要避免这种情况。\n\n例2：\n\n```js\nconsole.log(apple)\nif(0) {\n  var apple = 10\n}\n```\n\n上面代码会打印出 ‘undefined’，即使再运行阶段 `if` 代码块不会执行，但编译阶段可不管这些 `apple` 正常声明并赋值为 `undefined`。\n\n## 执行上下文栈（调用栈）\n\n### 概念\n\n执行上下文栈也可以叫”调用栈“，具有栈的后进先出结构。\n\n- 首次运行JS代码，JS引擎会编译当前环境代码（跳过函数），并创建一个“全局执行上下文”，然后 Push 到“执行上下文栈”中。\n- 编译结束。\n- 开始执行全局代码，执行中遇到函数调用时，当前“执行上下文”暂时挂起，编译该函数内部代码、创建一个“函数执行上下文”，Push 到“执行上下文栈”中，控制权交给“栈顶”的“函数执行上下文”，开始执行这个函数代码。\n- 如果这个函数没有执行完毕又调用了另一个函数，同样的暂时挂起，编译、创建一个新的”函数执行上下文“，并 Push 到执行上下文栈中，开始执行。\n- 当栈顶的函数执行完毕，会 Pop 出执行上下文栈，并将控制权交给当前栈顶的“执行上下文”，继续执行代码。\n\n这就是“执行上下文栈”的概念。\n\n### 例子\n\n**文字描述太抽象？没有关系看例子：**\n\n```js\nvar a = 'Hello World!'\n\nfunction first() {  \n  console.log('Inside first function')\n  second()  \n  console.log('Again inside first function')\n}\n\nfunction second() {  \n  console.log('Inside second function')  \n}\n\nfirst()  \nconsole.log('Inside Global Execution Context')\n```\n\n对于上面的代码，执行上下文栈变化过程：\n\n![图示](https://s2.loli.net/2023/03/18/NBnvMFdqofpCxHs.webp)\n\n一些需要注意的点：\n\n- JS引擎在函数被调用之前不会编译内部的代码。\n- 当一个函数被调用时，一个新的执行上下文会被创建并 push 到栈顶。\n- 所有的执行上下文被管理到一个栈中\n- 任何时候一个函数被调用都会发生编译和执行两个步骤\n\n执行上下文栈，也可以成为调用栈。\n\n### 在 chrome 中查看执行上下文栈\n\n在 Sources 选项卡，通过打断点的方式即可查看，如图：\n\n![](https://s2.loli.net/2023/03/18/h9lR3DgLv5wjuNi.png)\n\n## 词法环境和块级作用域\n\n自从 ES6 更新后，js 有三种作用域（不考虑 `eval`）\n\n*   全局作用域\n*   函数作用域\n*   块级作用域\n\n全局作用域对应全局执行上下文，函数作用域对应函数执行上下文。\n\n而块级作用域有所不同。\n\n### 块级作用域\n\n用块级作用域和全局、函数作用域做比较会很好理解。\n\n> 由于全局作用域和函数作用域的表现相似，本节忽略函数作用域讲解。\n\n先来看一个全局作用域的例子：\n\n```js\nvar apple = 'apple'\n\nif(true) {\n  var apple = 'banana'\n  console.log('if apple:', apple)\n}\n\nconsole.log('Global apple:', apple)\n```\n\n上面代码，两处都会打印：‘banana’。这很好理解，执行阶段后一个赋值覆盖了前一个。\n\n\n\n> *下面开始讲解块级作用域。*\n\n我们通过使用 `let` 来重写上面的例子，来介绍块级作用域。\n\n```js\nvar apple = 'apple'\n\nif(true) {\n  let apple = 'banana'\n  console.log('if apple:', apple)\n}\n\nconsole.log('Global apple:', apple)\n```\n\n上面代码执行结果：\n\n- ‘if apple: banana’\n- ‘Global apple: apple’\n\n为什么在同一个执行上下文中可以保存两个 `apple` 变量？\n\n这个时候就要开始讨论**词法环境**了。\n\n#### 词法环境（Lexical environment）\n\n对于上面的例子，在编译阶段 `apple` 的被赋值为 `undefined` 并添加到全局执行上下文的变量环境中。如图：\n\n![](https://s2.loli.net/2023/03/18/6xHBQPMeFzbEvDa.png)\n\n此刻，第二 `apple` 变量会被 JS 引擎跳过，因为：\n\n- 它是一个 `let` 创建的变量\n- 它在一个块级作用域中\n\n在执行阶段，第一个 `apple` 变量被赋值为了 ‘apple’。如图：\n\n![](https://s2.loli.net/2023/03/18/pTiYuG8RDjcdqQN.png)\n\n当读到 if 代码块时，一个嵌套的编译步骤发生。第二个值为 undefined 的 apple 变量被创建。\n\n这个 apple 变量被添加到词法环境，而不是在变量环境中创建它。\n\n![](https://s2.loli.net/2023/03/18/Aj9Lui8D2ny7Ysr.png)\n\n马上，在词法环境中，一个 “banana” 值被被赋值到 apple 变量。\n\n![](https://s2.loli.net/2023/03/18/XGtVSakQui8BUvl.png)\n\n现在，我们有两个同名变量被管理在两个环境中，那就是 js 引擎如何处理 let 声明，并且它向前兼容 var。\n\n#### 词法环境中的作用域栈\n\n为了更好地理解 `let` 和 `var` 之间的不同，让我们将他们合并在一个有趣的例子中。\n\n![](https://s2.loli.net/2023/03/18/fDhxOMEtYmLnJqs.png)\n输出：\n\n- global apple\n- block banana\n- global banana\n- global grape\n- orange is not defined\n\n有些反直觉？下面开始解释。\n\n在编译阶段，apple 和 grape 变量在变量环境中被初始化，grape 初始化被提升。与此同时，banana 变量在词法环境中被创建。\n\n![](https://s2.loli.net/2023/03/18/g7aN1kYJrQAotDe.png)\n\n执行阶段开始，变量 apple 被赋值为 “global apple”，而 banana 值为 “global banana”。\n\n![](https://s2.loli.net/2023/03/18/gF4BokHItLUZDJc.png)\n\n是时候关注代码块里的变量了\n\n它是另一个 banana 变量，在同一个词法环境里能够有两个相同名字的 banana 变量吗？\n\n当在块级作用域里看见 `let` 或 `const` 声明的变量时，js 引擎会为它们分别创建一个分开的区域，词法环境会为它内部的变量维护一个类似于栈的结构，所以同名变量不会相互冲突。\n\n![](https://s2.loli.net/2023/03/18/fvWu3T8rFyY5mNX.png)\n\n在这里，变量 banana 和 orange 放置在一个单独的作用域\n\n![](https://s2.loli.net/2023/03/18/BGAlb6TnsDHfkKU.png)\n\n接下来，所有的变量被分配一个相关的值。\n\n![](https://s2.loli.net/2023/03/18/iMWV32dtqge51SU.png)\n\n执行完最后的赋值语句后，所有的变量准备完毕。\n\n当打印第一个变量时，js 引擎首先尝试在词法环境中从顶部到底部查找 apple 变量，然后它检查全局变量环境并找到 apple 变量，打印 “global apple”。\n\n![](https://s2.loli.net/2023/03/18/G4QObF6jzlUXo5J.png)\n\n当搜索 banana 变量时，js 引擎根据同样的步骤，找到它并打印 “block banana”。\n\n![](https://s2.loli.net/2023/03/18/y9gK3DkcxiLu5sv.png)\n\n此刻，代码块里没有更多可执行的代码了，所以块级作用域被移除。\n\n![](https://s2.loli.net/2023/03/18/ZLYzibnPa84TGKD.png)\n\n脚本继续执行，在全局变量环境里找到 banana 和 grape 变量并相应地打印 “global banana” 和“global grape”。\n\n![](https://s2.loli.net/2023/03/18/eqjUrtGIu19cYhW.png)\n\n当脚本查找 orange 变量时，这个变量不存在于任何地方，因为 orange 存在的作用域已经被移除。所以会抛出错误 “orange is not defined”。\n\n![](https://s2.loli.net/2023/03/18/DghjqENGVycSYaO.png)\n\n整个脚本执行完毕。\n\n除了作用域，这里还有其他与 let 和 const 相关的问题吗？\n\n#### 创建，初始化和赋值的技巧\n\n从编译到执行，一个变量经历三个步骤：\n\n*   创建\n*   初始化\n*   赋值\n\n![](https://s2.loli.net/2023/03/18/7IOx4GSMrlc8adv.png)\n\n上面的代码将会打印什么？是 “apple”？或者是 “banana”？\n\n出人意料，它会报错 “Cannot access `apple`before initialization”\n\n这个错误与提升有关。\n\n*   对于一个 `let` 声明的变量，它的创建会被提升，但是初始化和赋值不会被提升。\n*   对于一个 `var` 声明的变量，它的创建和初始化会被提升，赋值不会被提升。\n*   对于一个函数，它的创建，初始化和赋值在同一时间都被提升。\n\n人们把代码初始化之前的区域称为**暂时性死区**\n\n*   如果你尝试在一个变量创建之前访问它，你将会看见一个错误 “[variable name] is not defined.”\n*   如果你决定在一个变量初始化之前访问它，你将会看见错误 “Cannot access [variable name] before initialization.”\n*   如果你在一个变量赋值之前打印它，你将会看见打印 undefined。\n\n## 作用域链、闭包和 this\n\n在理解了执行上下文后，作用域链、闭包、this 这些概念理解起来就很容易了。\n\n### 作用域链 与 外部引用（outer）\n\n我们先来看一个令人迷惑的例子\n\n```js\nvar apple = 'apple'\n\nfunction isApple() {\n  console.log(apple)\n}\n\nfunction isBanana() {\n  var apple = 'banana'\n  isApple()\n}\n\nisBanana()\n```\n\n问：上面的代码输出什么？\n\n许多人的第一直觉是‘banana’，但正确的答案是 ‘apple’。\n\n这是因为作用域链是由 outer 决定，而 outer 又是由编译阶段决定的。\n\n上面的例子，因为两个函数都声明在全局作用域，所以在编译阶段 outer 就被指向了全局执行上下文，不会改变。\n\n**作用域链由编译阶段决定，重来不受调用栈影响。**\n\n### 闭包\n\n闭包理解起来比听起来更加直观，让我们来看一个例子\n\n![](https://s2.loli.net/2023/03/18/yLARvPuorBdnjbN.png)\n\n在返回 util 并将其分配给 `price` 变量之前，我们有以下调用堆栈。\n\n![](https://s2.loli.net/2023/03/18/ZUrHB5RfyuF6Vd3.png)\n\n在返回 util 之后，`applePrice` 函数执行结束，并且它的执行上下文被移除。\n\n与此同时，变量环境和词法环境消失，并且它们内部的变量应该被销毁。\n\n![](https://s2.loli.net/2023/03/18/rVJFS6t4ZWLgTdz.png)\n\n此时，js 的一个规则起作用了——一个内函数总是可以访问它外函数的变量\n\n在这里，内函数是`getPrice`和`setPrice`，外函数是`applePrice`\n\n`getPrice` 函数使用两个变量`fruit` 和 `price`，而`setPrice` 函数使用 `price` 变量\n\n根据这个规则，`fruit` 和 `price` 变量应该被保存在一个分离的区域，这是一个仅仅只能被`getPrice`和`setPrice`函数访问的独立的区域，也被称为**闭包**。\n\n![](https://s2.loli.net/2023/03/18/HFncdhtN2xrlQKG.png)\n\n与此同时，`discount` 变量被销毁，因为没有方法有引用指向它。\n\n接下来，继续执行代码，并调用 `setPrice` 函数，js 引擎浏览作用域链，并在闭包中定位到 `price` 变量。`price` 的值被设置为 “20”。\n\n![](https://s2.loli.net/2023/03/18/ZWJQYFnGTH7rLMj.png)\n\n在最后一行，`getPrice` 函数被调用，通过同样的链式查找，js 引擎在闭包中找到 `fruit` 和 `price` 变量，并打印“apple”和“20”。`\n\n![](https://s2.loli.net/2023/03/18/k23EgFModz89ALn.png)\n\n执行结束。\n\n通过在 chrome 中运行这个例子的代码，你可以在它的开发者工具中看到闭包\n\n![](https://s2.loli.net/2023/03/18/a8DTKEzLNxW6X5M.png)\n\n### this\n\n> 在创建执行上下文时就会绑定 this，至于 this 指向谁，取决于调用方式。\n\n我们已经接触了执行上下文的三个组成部分\n\n*   变量环境\n*   词法环境\n*   outer\n\n最后一个是 this\n\n![](https://s2.loli.net/2023/03/18/8ho4tLfpb57OXR9.png)\n\n每个作用域都有自己的 this\n\n如果我们在全局作用域中打印 this，我们将会收到一个 window 对象。\n\nwindow 对象是 this 和作用域概念联系的唯一元素，因为它是位于作用域链的根部，作为全局作用域的一部分。\n\n函数作用域中的 this 是怎样的呢？\n\n![](https://s2.loli.net/2023/03/18/p5jy7dCZqNeYD8f.png)\n\nthis 是指 applePrice 函数吗？\n\n令人意外的是，控制台会打印 window 对象，跟它在全局作用域中运行一样。\n\nthis 跟任何作用域没有关联。\n\n但是 this 是什么？它是否总是指向 window 对象？\n\n**this 是什么？**\n\n让我们看下一个例子\n\n![](https://s2.loli.net/2023/03/18/k1D7WjswuO9GhFl.png)\n\n在这个例子中，getPrice 函数打印 “10”，getThis 函数打印 apple 对象。\n\n所以我们找到了答案：谁调用这个方法谁就是 this。\n\nouter 是在编译阶段被定义，而 this 是由执行阶段决定。\n\n当一个函数被声明，它被附属到 window 对象上，当你执行一个函数，window 对象正是函数的调用者，因此，this 指向 window 对象。\n\n我们可以通过改变调用者来重置 this\n\n![](https://s2.loli.net/2023/03/18/MSpdgYsEZubOWDy.png)\n\n在最后一行，我们通过 call 函数来改变 this 指向 banana 对象\n\n当 js 引擎执行最后一行代码时，正是 banana 对象在调用函数，因此 this 是 banana，控制台打印 “20”。\n\n**this 转换成作用域概念**\n\n尽管 this 跟作用域没有任何关系，但我们可以简单地将它转换成作用域概念\n\n下面的例子展示了一个使用 this 时的经典问题\n\n![](https://s2.loli.net/2023/03/18/jihbJVcSEANOPkC.png)\n\n谁调用了`discount` 函数？\n\n乍一看，像是`getPrice` 函数在调用它，然而，控制台却打印 window 对象\n\n到目前为止，我们知道一个函数（或方法）不是由函数调用，而是由 window 或者一个对象调用，在这个例子中，是 window 对象调用了 `discount` 函数。\n\n这是 js 设计的一个缺陷，this 不能够从外部作用域继承，因为它从来都不是作用域的一部分。\n\n我们可以通过将 this 赋值给一个局部变量来很快修复这个问题\n\n![](https://s2.loli.net/2023/03/18/cRl2fwJhLKUeW9P.png)\n\n通过这么做，作用域链可以正常工作。\n\n自从 ES6 后，我们可以通过使用箭头函数来避免使用一个多余的 self 变量。\n\n![](https://s2.loli.net/2023/03/18/SBdscr17HJaxN2A.png)\n\n箭头函数没有绑定 this，它共享外部环境相同的 this。\n\n## 关于执行上下文的版本\n\n由于ES已经迭代多个版本，执行上下文的标准也有一定变化：\n\n**ES3 标准中的执行环境**\n\n- scope：作用域，如果有作用域嵌套的情况就称作\"作用域链\"。\n- variable object：变量对象，用于存储标识符的特殊对象。\n- this value：this 值。\n\n这也是经常看到一些文章提到VO、AO的原因，注意分辨即可。\n\n\n\n**ES6 标准中的执行环境**\n\n- variable environment：变量环境，当声明变量时使用。\n- lexical environment：词法环境，当获取标识符值或者 this 值时使用。\n\n","views":124}]