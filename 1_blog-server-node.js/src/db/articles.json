[{"id":1,"time":1672441448575,"title":"百分比布局","intro":"百分比布局","content":"# 百分比布局\n\n\n```html\n<section>\n    <div></div>\n    <div></div>\n</section>\n```\n\n```css\n* {\n    margin: 0;\n    padding: 0;\n}\n\nsection {\n    width: 100%;\n    /* 一般会设置一个范围，避免变形 */\n    max-width: 980px;\n    min-width: 320px;\n    margin: 0 auto;\n}\n\nsection div {\n    float: left;\n    width: 50%;\n    height: 400px;\n}\n\nsection div:nth-child(1) {\n    background-color: pink;\n}\n\nsection div:nth-child(2) {\n    background-color: purple;\n}\n```\n","views":9},{"id":2,"time":1672441497206,"title":"操作系统的一些概念","intro":"操作系统的一些概念","content":"# 操作系统的一些概念\n\n## 内存管理\n\n很早前 DOS 时代，内存是由程序自己控制。\n\nwindows 时代，由操作系统统一管理。\n\n以32为操作系统为例，最多能够管理的内存为4G。\n\n每个程序看到的都是4G的虚拟内存，实际上由操作系统来映射真实的内存地址。这样做不需要关心真实的内存地址，降低心智负担。\n\n **虚拟存储器**\n\n1. 现代CPU都有多个核心，其中 ALU（计算单元）从 CPU 寄存器拿数据用于计算。CPU 寄存器存取数据非常快，但容量极小，也最贵。\n2. 每个核心有自己的缓存：L1 速度比寄存器慢一些、大很多、便宜一些；L2 较 L1 更慢一些、大一些、便宜一些；整个CPU还有一个 L3 缓存，较 L2 更慢、更大、更便宜；\n3. 内存：就是内存条，较 L3 缓存更慢、更大、更便宜。\n4. 硬盘：持久化的存数据，较内存条更慢、更大、更便宜。速度上：SSD > 机械。\n5. 再慢点的就是网络传输\n\n搞这么多级就是为了在速度与成本间做取舍。\n\n存储器山：寄存器 > L1 > L2 > L3 > 内存 > 硬盘。\n\nCPU在执行时就是逐级往上加载数据。\n\n**虚拟存储器，统一的内存模型**\n\n以一个4G内存的电脑为例，每一个程序看到的都是4G的虚拟内存。\n假设：\nA程序使用了1G。\nB程序使用了1G。\n\n> **页表**：A 和 B 看到的都是4G的虚拟内存，虚拟内存地址看起来一样。但数据实际存储的物理内存地址肯定是不一样的。这个映射关系是由一个称为“页表”的东西来记录的。操作系统中每一个进程都会有一个“页表”，用来记录映射关系。\n>\n> 此时C程序马上需要3G内存来执行。\n> 这个时候就需要把A或B卸载，写入硬盘缓存里保存起来。腾出了1G空间，刚好够C程序运行，再加载C程序。（这个过程是由操作系统来执行的。）\n>\n> 假设我马上又需要执行A程序，这个时候就又有一个IO过程，会严重拖慢电脑。\n## 驱动\n\n对硬件的抽象层，向外暴露一个统一的接口。\n\n比如 usb 键盘、蓝牙键盘，通过驱动抽象统一接口，使你无需关心兼容问题。\n\n## 文件系统\n\n可以理解为一个很大的数组。\n\n[meta元信息 文件位置 文件大小] 这样就可以快速的找到文件。\n\n平时使用的快速（高级）格式化，实际上就是把元信息清除。如果实际文件没有被覆盖的话，可以恢复。\n\n常规（低级）格式化就不行了。\n\n## 进程、线程\n\n> windows可以通过任务管理器直接查看进程。\n\n进程是资源分配的最小单位，可以理解为一个容器，每个进程都有自己单独的页表（映射内存地址）。因为共享页表，进程内的多个线程可以共享数据。\n\n线程是CPU运算调度的最小单位，一个单一顺序的控制流，用于执行某个任务。一个进程中可以有n个线程，线程共享数据（页表）。\n\n### 进程是如何实现的？\n\n进程的实现其实和你的cpu是单核还是多核没有关系，它是把一段时间切分的非常小，称为“时间片”，每个时间片只执行某个程序的很小一部分，因为时间非常的短，人类无法感知，使你能够“同时”执行多个操作，多个程序也能同时的推进。\n\n### 多线程\n\n在一个进程中，你可能需要执行多个操作，这个时候就需要开多个线程。\n线程间可以共享进程内的数据（共享页表）。\n\n### 进程和线程的区别\n\n进程间通信比较麻烦，如：pipe（管道）、file、socket，都需要中转，所以很慢。\n\n线程间通信很简单，因为它们共享同一张页表，数据都是可见的，所以它们可以互相通信。\n\n而进程间都有自己的页表，它们都认为自己独占所有内存，它们互相看不见，所以需要通过中间层来实现通信。\n\n### 多线程同步问题\n\n多个线程的调度是由操作系统决定的，程序无法决定。因此，某个线程可能在任何指令处被操作系统暂停，然后在某个时刻恢复。\n\n这就会出现一个问题：当多个线程读写共享变量时，可能造成数据不一致。\n\n**例子：A、B两个线程，对 count 进行加一操作。**\n\n- 一个文件存了个变量 count = 0\n- A线程读取并count加一，此时count为1。这时，操作系统将本线程暂停，还没来得及保存到文件，就切换到线程B。\n- B线程也读取并count加一，此时count还是1，保存到文件。\n- 切换到A线程继续执行操作：保存。这就出现问题了，我们期望count是2，却被覆盖保存，count还是1。\n\n造成上面问题的核心就是，A、B线程可被拆分，它们不是“原子操作”。\n\n#### 解决方案：加锁\n\n常见的有：互斥锁、条件变量、读写锁、自旋锁、信号量。\n\n这里只介绍互斥锁：A线程访问变量，加锁，在A线程没有结束操作并解锁前，其他线程都需要等待。这样就保证了操作的原子性。\n\n#### 新的问题：死锁\n\n**什么是死锁？**\n\n现在有两个资源1和资源2，我们有A、B两个线程去访问。\n\n- A要先拿1再拿2才进行操作，拿不全就等待。\n- B要先拿2再拿1其他同上。\n\n假设它们两个线程抢的都非常快，A拿了1、加锁，B拿了2、加锁。\n\n因为它们要拿全资源才进行操作，所以它们都会等待对方手里的资源，两个线程就会无限的等待，陷入“死锁”。\n\n**解决方案**\n\n1. 调整顺序，A、B两个线程都先拿1再拿2\n2. 两个线程都必须拿到全部资源才操作（该例中1和2都拿到），否者扔掉。\n\n## 并发、并行\n\n并发：一段时间内，多个任务流可以交替执行。\n\n并行：真正（物理）意义上的同时执行多个任务，由多个 CPU 核心同时执行。\n\n**举个例子：你在吃面，突然来了电话。**\n\n- 并发：你停止吃面，接完了电话再继续吃面。\n- 并行：你一边吃面，一边接电话。\n\n## 同步异步 阻塞非阻塞\n\n- 同步：事件的发生与否，需要你自己去检查。\n\n- 异步：事件的发生与否，是由别人通知给你的。\n\n比如 AJAX 可以同步也可以异步。\n\n你同步请求，就会一直等待服务器返回数据，不继续执行代码。\n\n而异步请求，会把回调函数放到一边，继续执行其他任务，等返回数据了再通知你继续执行。\n\n- 阻塞：上面例子的 AJAX 同步请求就是阻塞。\n- 非阻塞：AJAX 异步请求就是非阻塞。\n\n## 编译 解释 JIT\n\n编译：比如C语言，编译到机器码（机器指令码）才可执行。编译会很慢，而且不同的平台需要编译不同版本，因为它们的指令集不同。\n\n解释：比如使用C语言针对不同平台（windows、Mac、Linux…）开发一个虚拟机，它的指令集是固定的。这时比如你有一个Python语言，只需要逐条的转换成这个虚拟机的指令即可。\n\nJIT（just-in-time compilation）即时编译：JavaScript就是JIT的语言，只编译、执行需要的代码，还会把运行次数很多的代码编译成机器码，省略了中间转换步骤以提高效率。更多操作可以看这篇译文：[JavaScript 编译 - JIT (just-in-time) compiler 是怎么工作的](https://zhuanlan.zhihu.com/p/99395691)\n\n## 动态语言与静态语言\n\n动态语言：\n\n```js\nvar a = ''\n//可转换类型\na = []\na = {}\n```\n\n静态语言：`a = ''` 以后只能是 String 类型，不能再转换为其他类型了。\n\n## 强类型与弱类型\n\n强类型：`1 + '1'` 报错。\n\n弱类型：如 JS `1 + '1'` 结果是 `'11'`。\n\n## 有GC 与 无GC\n\nGC（Garbage Collection）：垃圾回收。\n\n有GC的语言：JavaScript、Python、Golang、java等\n\n无GC的语言：C、C++\n\n无GC的语言，比如你 `new ` 了一个东西，你需要记得 `delete` 否者就一直占着内存。\n\n有GC的语言，会自动帮你回收不用的东西，有效降低心智负担。\n\n## 常见的GC算法\n\n### 引用计数法\n\n> 这个算法非常初级，早期浏览器就是采用的这种方法。\n\n对于一个对象a，如果没有其他对象引用它，就垃圾回收。\n\n**以JS代码为例**\n\n```js\nvar a = {\n  name: 'monkey'\n}\n\nvar b = a // 此时有两个变量引用了该对象\n\na = 1 // 只有一个(b)了\nb = null // 0个引用，上面的对象被垃圾回收\n```\n\n**局限：循环引用**\n\n引用计数法无法解决循环引用无法回收的问题，下面以JS为例：\n\n```js\nvar f = function() {\n  var o1 = {}\n  var o2 = {}\n  o1.a = o2\n  o2.b = o1\n}\n\nf()\n```\n\n上面例子两个对象互相引用，构成一个循序，它们两个对象都持有一个引用，导致无法被垃圾回收。（这种现象叫做内存泄漏。）\n\n### 标记-清除算法\n\n> 关于浏览器：从2012年起，所有的现代浏览器都是用了该算法。所以不用担心上一节的循环引用问题了。\n\n该算法把GC分为了两个阶段：\n\n- 标记阶段：把所有的活动对象做上标记。\n- 清除阶段：把没有标记的对象销毁。\n\n**具体实现**\n\n标记：\n\n- 这个算法假定设置一个根（root）对象（JS中就是 window）。\n\n- 垃圾回收器会定期从根开始，找所有从根开始引用的对象，然后找这些对象的引用对象，这样逐层遍历下去，把遍历到的对象打上标记。\n\n清理：\n\n- 整个再遍历一遍，没有被标记的对象被垃圾清理。\n\n## 协程\n\n> 朋友聚会去饭馆，点好菜可以有两种吃法，第一种，等菜上完大家动筷子，第二种，上一道吃一道。如果按第一种吃法，吃饭的程序要等待做饭的程序（饭馆）全部执行完；按第二种吃法，吃饭的程序和做饭的程序就完成了解耦，做饭的做他的，快或者慢，只要上，吃饭的就吃，不依赖一个最终状态。这两种方法不改变菜的品种质量。但流程效益却不同，如果上一道吃一道，吃完的盘子就可以清掉，如果按第一种吃法，上到中间发现桌子不够大，盘子要叠罗汉。而且第一种吃法，喜欢吃某个菜的朋友可以先吃到，不必死等流口水。如果点三道菜，两种吃法或许没太大差异。但是你想像一下，假设点了3000道菜，两种吃法的效率当下立现，如果按第一种吃法，大家都饿死了，即使做好了，桌子（内存）也放不下。\n>\n> 我上面说解耦，并不完全准确，准确得说，**吃饭的程序不再依赖于整桌菜，而只依赖于下一道菜**，而依赖于前者往往空间和时间效益都低，而依赖于后者较高。\n>\n> 作者：dboy\n> 链接：https://www.zhihu.com/question/55810122/answer/146654766\n> 来源：知乎\n\n协程是在单核CPU场景中发展出来的概念，通过**挂起**、**恢复**接口，把一个线程切分成了多个任务段（控制权是由程序决定），以实现交叉执行多个任务的并发功能。\n\n协程相比于多线程的优势就是，线程切换需要消耗资源，比如你有10000个用户请求，你开10000个线程资源消耗是可怕的，而协程是对线程的时间片做分配，有效降低开销。\n\n实际开发中，协程适合IO密集型的任务。协程中不要同步的调用阻塞IO的方法（如：文件读取），协程要配合异步IO才能发挥最大威力，通过挂起、恢复操作以最大程度利用CPU。\n","views":41},{"id":3,"time":1675004119864,"title":"123","intro":"1","content":"12333","views":0},{"id":4,"time":1675004388502,"title":"1","intro":"1","content":"1","views":0},{"id":5,"time":1675004399682,"title":"2","intro":"2","content":"1","views":0},{"id":6,"time":1675004405815,"title":"3","intro":"3","content":"1","views":0},{"id":7,"time":1675004411619,"title":"4","intro":"2","content":"2","views":0},{"id":8,"time":1675004418482,"title":"5","intro":"5","content":"1","views":0},{"id":9,"time":1675004425918,"title":"6","intro":"2","content":"6","views":0},{"id":10,"time":1675004431757,"title":"7","intro":"7","content":"7","views":0},{"id":11,"time":1675004439457,"title":"8","intro":"8","content":"8","views":0},{"id":12,"time":1675004445730,"title":"9","intro":"9","content":"9","views":0},{"id":13,"time":1675004453451,"title":"10","intro":"1","content":"1","views":0},{"id":14,"time":1675004461641,"title":"12","intro":"12","content":"1","views":0},{"id":15,"time":1675004467795,"title":"13","intro":"1","content":"1","views":0},{"id":16,"time":1675004473832,"title":"14","intro":"14","content":"1","views":0},{"id":17,"time":1675004479545,"title":"15","intro":"1","content":"1","views":0},{"id":18,"time":1675004486696,"title":"16","intro":"11","content":"1","views":0},{"id":19,"time":1675004494353,"title":"18132","intro":"1","content":"1","views":0},{"id":20,"time":1675004498873,"title":"123","intro":"12","content":"1","views":0},{"id":21,"time":1675007036241,"title":"21","intro":"1","content":"1123","views":0},{"id":22,"time":1675007059894,"title":"12333","intro":"333","content":"555555555","views":0}]